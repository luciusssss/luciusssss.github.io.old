<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog - Lucius</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://luciusssss.github.io/"/>
  <updated>2020-08-03T12:50:57.651Z</updated>
  <id>http://luciusssss.github.io/</id>
  
  <author>
    <name>Lucius</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Stanford Compilers 笔记</title>
    <link href="http://luciusssss.github.io/2020/08/03/Stanford-Compilers-%E7%AC%94%E8%AE%B0/"/>
    <id>http://luciusssss.github.io/2020/08/03/Stanford-Compilers-%E7%AC%94%E8%AE%B0/</id>
    <published>2020-08-03T11:50:16.000Z</published>
    <updated>2020-08-03T12:50:57.651Z</updated>
    
    <content type="html"><![CDATA[<p>斯坦福编译网课的笔记</p><h2 id="编译器构成"><a href="#编译器构成" class="headerlink" title="编译器构成"></a>编译器构成</h2><ol><li>Lexical Analysis</li><li>Parsing</li><li>Semantic Analysis</li><li>Optimization</li><li>Code Generation</li></ol><h2 id="Lexical-Analysis"><a href="#Lexical-Analysis" class="headerlink" title="Lexical Analysis"></a>Lexical Analysis</h2><p>词法分析需要做两件事：</p><ul><li>将输入划分成lexeme</li><li>识别出每个lexeme的token class</li></ul><p>过程：</p><p><img src="/2020/08/03/Stanford-Compilers-%E7%AC%94%E8%AE%B0/lexical_analysis.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;斯坦福编译网课的笔记&lt;/p&gt;
&lt;h2 id=&quot;编译器构成&quot;&gt;&lt;a href=&quot;#编译器构成&quot; class=&quot;headerlink&quot; title=&quot;编译器构成&quot;&gt;&lt;/a&gt;编译器构成&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Lexical Analysis&lt;/li&gt;
&lt;li&gt;Parsing&lt;
      
    
    </summary>
    
    
      <category term="编译" scheme="http://luciusssss.github.io/categories/%E7%BC%96%E8%AF%91/"/>
    
    
      <category term="编译" scheme="http://luciusssss.github.io/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>统计学习方法笔记5 SVM</title>
    <link href="http://luciusssss.github.io/2020/04/12/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B05-SVM/"/>
    <id>http://luciusssss.github.io/2020/04/12/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B05-SVM/</id>
    <published>2020-04-12T00:50:54.000Z</published>
    <updated>2020-08-03T11:13:44.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性可分支持向量机-amp-硬间隔最大化"><a href="#线性可分支持向量机-amp-硬间隔最大化" class="headerlink" title="线性可分支持向量机&amp;硬间隔最大化"></a>线性可分支持向量机&amp;硬间隔最大化</h1><h2 id="线性可分支持向量机"><a href="#线性可分支持向量机" class="headerlink" title="线性可分支持向量机"></a>线性可分支持向量机</h2><p>给定线性可分训练数据集，通过间隔最大化或者等价地求解相应的凸二次规划问题得到的分离超平面为$w^{*} \cdot x + b^{*} = 0$和分类决策函数$f(x) = \textrm{sign}(w^{*} \cdot x + b^{*})$称为线性可分支持向量机。</p><h2 id="函数间隔-amp-几何间隔"><a href="#函数间隔-amp-几何间隔" class="headerlink" title="函数间隔&amp;几何间隔"></a>函数间隔&amp;几何间隔</h2><p>超平面关于样本点的函数间隔$\hat{\gamma_i} = y_i(w\cdot x_i + b)$，关于训练集额函数间隔为$\hat{\gamma} = \min_{i = 1, \dots, N}\hat{\gamma_{i}}$。</p><p>几何间隔将其规范化，超平面关于样本点的几何间隔${\gamma_i} = y_i(\frac{w}{|w|}\cdot x_i + \frac{b}{|w|})$，关于训练集额函数间隔为${\gamma} = \min_{i = 1, \dots, N}{\gamma_{i}}$。</p><h2 id="间隔最大化"><a href="#间隔最大化" class="headerlink" title="间隔最大化"></a>间隔最大化</h2><p>SVM基本思想时求解能正确划分数据集并且几何间隔最大的分离超平面。</p><p>线性可分SVM可以转化成如下最优化问题<br>$$<br>\min_{w, b} \frac{1}{2}|w|^2 \ \textrm{s.t.}\ y_i(w \cdot x_i + b) - 1 \ge 0<br>$$</p><a id="more"></a><h2 id="学习的对偶算法"><a href="#学习的对偶算法" class="headerlink" title="学习的对偶算法"></a>学习的对偶算法</h2><p>首先构建拉格朗日函数<br>$$<br>L(w, b, \alpha) = \frac{1}{2}|w|^2 - \sum_{i = 1}^N \alpha_i y_i (w \cdot x_i + b ) + \sum_{i=1}^N \alpha_i<br>$$<br>其中$\alpha_i \ge 0, \ i = 1, \dots, N$。</p><p>根据拉格朗日对偶性，原始问题的对偶问题是极大极小问题<br>$$<br>\max_{\alpha}\min_{w, b} L(w,b,\alpha)<br>$$<br>先求$\min_{w, b}L(w, b, \alpha)$<br>$$<br>\nabla_{w} L(w, b, \alpha) = w - \sum_{i = 1}^{N} \alpha_i y_i x_i = 0<br>$$</p><p>$$<br>\nabla_b L(w, b, \alpha) = -\sum_{i = 1}^{N} \alpha_i y_i = 0<br>$$</p><p>得到$w = \sum_{i = 1}^{N} \alpha_i y_i x_i$, $\alpha_i y_i = 0$ 。</p><p>代入得到<br>$$<br>\begin{aligned}<br>L(w, b, \alpha) &amp; = \frac{1}{2} \sum_{i = 1}^N \sum_{j = 1}^N \alpha_i\alpha_j y_i y_j (x_i\cdot x_j) -\sum_{i = 1}^N \alpha_i y_i ((\sum_{j=1}^N \alpha_j y_j x_j) x_i + b) + \sum_{i = 1}^N \alpha_i \<br>&amp; = - \frac{1}{2} \sum_{i = 1}^N \sum_{j = 1}^N \alpha_i\alpha_j y_i y_j (x_i\cdot x_j)  + \sum_{i = 1}^N \alpha_i<br>\end{aligned}<br>$$<br>求$\min_{w,b}L(w, b, \alpha)$对$\alpha$的极大，即时对偶问题。将目标函数由极大转换成求最小，求得到<br>$$\min_{\alpha}  \frac{1}{2} \sum_{i=1}^N \sum_{j = 1}^N \alpha_i \alpha_j y_i y_j (x_i \cdot x_j) - \sum_{i = 1}^N \alpha_i$$<br>$$\textrm{s.t.} \sum_{i=1}^N \alpha_i y_i = 0 $$<br>$$\alpha_i \ge 0, \ i = 1, \dots, N$$</p><p>设$\alpha^{*}$是对偶问题的解，KKT条件成立，得到<br>$$<br>\begin{aligned}<br>\nabla_{w}L(w^{*}, b^{*}, \alpha^{*}) = w^{*} - \sum_{i=1}^N \alpha_i^{*}y_i x_i = 0 \<br>\nabla_b L(w^{*}, b^{*}, \alpha^{*}) = \sum_{i=1}^N \alpha_i^{*} y_i = 0 \<br> \alpha_i^{*}(y_i(w^{*} \cdot x_i + b^{*})-1) = 0, \ i = 1, \dots, N \<br>y_i(w^{*} \cdot x_i + b^{*})-1 \ge 0, \ i = 1, \dots, N \<br>\alpha_i \ge 0,\  i = 1, \dots, N<br>\end{aligned}<br>$$<br>由此得到$w^{*} =  \sum_{i=1}^N \alpha_i^{*}y_i x_i$。其中至少有一个$\alpha_j^{*} &gt; 0$，对它有$y_j(w^{*}\cdot x_j + b^{*}) -1 = 0$。注意到$y_j^2 = 1$，所以有$b^{*} = y_j - \sum_{i=1}^N \alpha_iy_i(x_i \cdot x_j)$。</p><p>分离超平面可以携程<br>$$<br>\sum_{i=1}^N \alpha_i^{*}y_i(x\cdot x_i) + b^{*} = 0<br>$$<br>分类决策函数可以写成<br>$$<br>f(x) = \textrm{sign}(\sum_{i=1}^N \alpha_iy_i(x\cdot x_i) + b^{*})<br>$$<br>它只依赖于输入$x$和训练样本输入的内积。</p><p>数据集中$\alpha_i&gt;0$的样本点称为支持向量。</p><h1 id="线性支持向量机-amp-软间隔最大化"><a href="#线性支持向量机-amp-软间隔最大化" class="headerlink" title="线性支持向量机&amp;软间隔最大化"></a>线性支持向量机&amp;软间隔最大化</h1><p>假设训练数据集不是线性可分的，引入松弛变量$\xi$<br>$$<br>\begin{aligned}<br>\min_{w, b, \xi} &amp; \frac{1}{2}|w|^2 + C \sum_{i=1}^N \xi_i \<br>\textrm{s.t.} &amp; y_i(w{*}x_i + b) \ge 1 - \xi_i,\ i = 1, \dots, N \<br>&amp; \xi_i \ge 0 ,\ i = 1, \dots, N<br>\end{aligned}<br>$$<br>拉格朗日函数<br>$$<br>L(w, b, \xi, \alpha, \mu) = \frac{1}{2}|w|^2 + C\sum_{i=1}^N \xi_i - \sum_{i=1}^N \alpha_i( y_i(w {*} x_i + b) - 1 + \xi_i) - \sum_{i=1}^N \mu_i \xi_i<br>$$<br>其中$\alpha_i \ge 0, \mu_i \ge 0$。</p><p>先对$w, b, \xi$求极小<br>$$<br>\begin{aligned}<br> \nabla_w L(w, b, \xi, \alpha, \mu) = w - \sum_{i=1}^N \alpha_i y_i x_i = 0\<br> \nabla_b L(w, b, \xi, \alpha, \mu) = -\sum_{i=1}^N \alpha_i y_i = 0 \<br> \nabla_\xi L(w, b, \xi, \alpha, \mu) = C - \alpha_i - \mu_i = 0<br>\end{aligned}<br>$$<br>得到<br>$$<br>\begin{aligned}<br> w = \sum_{i=1}^N \alpha_i y_i x_i \<br> \sum_{i=1}^N \alpha_i y_i = 0 \<br> C - \alpha_i - \mu_i = 0<br>\end{aligned}<br>$$<br>代入得到<br>$$<br>\min_{w, b, \xi} L(w, b, \xi, \alpha, \mu) = -\frac{1}{2} \sum_{i=1}^N\sum_{j=1}^N \alpha_i \alpha_j y_i y_j (x_i \cdot x_j) + \sum_{i=1}^N \alpha_i<br>$$<br>得到对偶最优化为<br>$$<br>\begin{aligned}<br>\max_{\alpha}&amp;  -\frac{1}{2} \sum_{i=1}^N\sum_{j=1}^N \alpha_i \alpha_j y_i y_j (x_i \cdot x_j) + \sum_{i=1}^N \alpha_i \<br>\textrm{s.t.} &amp; \sum_{i=1}^N \alpha_i y_i = 0 \<br>&amp; C - \alpha_i - \mu_i = 0, \ i = 1, \dots, N \<br>&amp; \alpha_i \ge 0 , \ i = 1, \dots, N \<br>&amp; \mu_i \ge 0 , \ i = 1, \dots, N \<br>\end{aligned}<br>$$<br>消去$\mu$<br>$$<br>\begin{aligned}<br>\max_{\alpha}&amp;  -\frac{1}{2} \sum_{i=1}^N\sum_{j=1}^N \alpha_i \alpha_j y_i y_j (x_i \cdot x_j) + \sum_{i=1}^N \alpha_i \<br>\textrm{s.t.} &amp; \sum_{i=1}^N \alpha_i y_i = 0 \<br>&amp; 0 \le \alpha_i \le C , \ i = 1, \dots, N \<br>\end{aligned}<br>$$<br>设$\alpha$是对偶问题的一个解，满足KKT条件<br>$$<br>\begin{aligned}<br> \nabla_w L(w^{*}, b^{*}, \xi^{*}, \alpha^{*}, \mu^{*}) = w^{*} - \sum_{i=1}^N \alpha_i^{*} y_i x_i = 0\<br> \nabla_b L(w^{*}, b^{*}, \xi^{*}, \alpha^{*}, \mu^{*})  = -\sum_{i=1}^N \alpha_i^{*} y_i = 0 \<br> \nabla_\xi L(w^{*}, b^{*}, \xi^{*}, \alpha^{*}, \mu^{*})  = C - \alpha_i^{*} - \mu_i^{*} = 0 \<br> \alpha_i^{*} ((y_i(w^{*} \cdot x_i) + b^{*} - 1 + \xi_i^{*}) = 0 \<br> \mu_i^{*} \xi_i^{*} = 0 \<br> \alpha_i^{*} \ge 0 \<br> y_i(w^{*} \cdot x_i) + b^{*} - 1 + \xi_i^{*} \ge 0 \<br> \mu_i^{*} \ge 0 \<br> \xi_i^{*} = 0 \<br>\end{aligned}<br>$$<br>得到$ w^{*} = \sum_{i=1}^N \alpha_i^{*} y_i x_i$。若存在$\alpha_j^{*}, 0 &lt; \alpha_j^{*} &lt; C$，则 $y_j(w^{*} \cdot x_j) + b^{*} - 1 = 0$。从而得到$b^{*} = y_j - \sum_{i = 1}^N y_i\alpha_i^{*}(x_i\cdot x_j)$</p><p>分离超平面可以写成<br>$$<br>\sum_{i = 1}^N y_i\alpha_i^{*}(x\cdot x_i) + b^{*} = 0<br>$$<br>分类决策函数写成<br>$$<br>f(x) = \textrm{sign} (\sum_{i = 1}^N y_i\alpha_i^{*}(x\cdot x_i) + b^{*})<br>$$<br>$\alpha_i^{*}&gt;0$的实例称为软间隔的支持向量。若$\alpha_i^{*} &lt; C$，则$\xi_i = 0$，支持向量恰好落在间隔边界上；当$\alpha_i^{*} = C$时，若$0 &lt; \xi_i &lt;1$，则分类正确，实例在间隔边界和分离超平面之间，若$\xi_i = 1$，实例在分离超平面上，若$\xi_i &gt; 1$，则实例在分离超平面误分类的一侧。</p><p>线性SVM原始最优化问题等价于<br>$$<br>\min_{w, b} \sum_{i=1}^N \max(1 - y_i(w\cdot x_1 + b), 0) + \lambda|w|^2<br>$$</p><h1 id="非线性支持向量机-amp-核函数"><a href="#非线性支持向量机-amp-核函数" class="headerlink" title="非线性支持向量机&amp;核函数"></a>非线性支持向量机&amp;核函数</h1><h2 id="核技巧"><a href="#核技巧" class="headerlink" title="核技巧"></a>核技巧</h2><p>通过非线性变换将原空间的数据映射到新空间，在新空间里用线性分类学习方法从训练数据里学习分类模型。</p><h2 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h2><p>如果存在一个从输入空间$\mathcal{X}$到特征空间$\mathcal{H}$的映射$\phi(x): \mathcal{X}\to \mathcal{H}$使所有$x, z \in \mathcal{X}$，函数$K(x, z)$满足条件$K(x, z) = \phi(x) \cdot \phi(z)$，则称$K(x, z)$为核函数。</p><p>$K(x, z)$为正定核函数的充要条件为对任意$x_i \in \mathcal{X}, i = 1, \dots, m$，$K(x, z)$对应的Gram矩阵$K = [K(x_i, x_j)]_{m\times m}$是半正定矩阵。</p><p>常用核函数：</p><p>多项式核函数：$K(x, z) = (x\cdot z + 1)^p$</p><p>高斯核函数：$K(x, z) = \exp(- \frac{|x - z|^2}{2\sigma^2})$</p><p>字符串核函数：</p><p>考虑字符串$s$的子串$u$，给定指标序列$i$，$u = s(i)$，第一个字符到最后一个字符的距离为$l(i)$。$R^{\Sigma^n}$表示定义在所有长度为$n$的字符串的集合上的实数空间，每一维对应一个字符串$u \in \Sigma^n$，映射$\phi_n(s)$将字符串$s$映射$R^{\Sigma^n}$上的一个向量，其在$u$维上的取值为$\lbrack \phi_{n} (s)\rbrack_u = \sum_{i:s(i) = u}\lambda^{l(i)}$。最终得到核函数<br>$$<br>k_n(s, t) = \sum_{u \in \Sigma^n} \lbrack  \phi_n(s)\rbrack_u \lbrack  \phi_n(t)\rbrack_u =  \sum_{u \in \Sigma^n} \sum_{(i, j):s(i) = t(j) = u} \lambda^{l(i)}   \lambda^{l(j)}<br>$$</p><h2 id="非线性支持向量机"><a href="#非线性支持向量机" class="headerlink" title="非线性支持向量机"></a>非线性支持向量机</h2><p>从非线性分类训练集，通过核函数与软间隔最大化，学习到的分类决策函数<br>$$<br>f(x) = \textrm{sign}(\sum_{i=1}^N \alpha_i^{*} y_i K(x, x_i) + b^{*})<br>$$<br>称为非线性支持向量机。</p><h1 id="SMO算法"><a href="#SMO算法" class="headerlink" title="SMO算法"></a>SMO算法</h1><p>不断地将原来的二次规划问题分解为只有两个变量的二次规划子问题，并对子问题进行解析求解，直到所有变量所有变量满足KKT条件。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线性可分支持向量机-amp-硬间隔最大化&quot;&gt;&lt;a href=&quot;#线性可分支持向量机-amp-硬间隔最大化&quot; class=&quot;headerlink&quot; title=&quot;线性可分支持向量机&amp;amp;硬间隔最大化&quot;&gt;&lt;/a&gt;线性可分支持向量机&amp;amp;硬间隔最大化&lt;/h1&gt;&lt;h2 id=&quot;线性可分支持向量机&quot;&gt;&lt;a href=&quot;#线性可分支持向量机&quot; class=&quot;headerlink&quot; title=&quot;线性可分支持向量机&quot;&gt;&lt;/a&gt;线性可分支持向量机&lt;/h2&gt;&lt;p&gt;给定线性可分训练数据集，通过间隔最大化或者等价地求解相应的凸二次规划问题得到的分离超平面为$w^{*} \cdot x + b^{*} = 0$和分类决策函数$f(x) = \textrm{sign}(w^{*} \cdot x + b^{*})$称为线性可分支持向量机。&lt;/p&gt;
&lt;h2 id=&quot;函数间隔-amp-几何间隔&quot;&gt;&lt;a href=&quot;#函数间隔-amp-几何间隔&quot; class=&quot;headerlink&quot; title=&quot;函数间隔&amp;amp;几何间隔&quot;&gt;&lt;/a&gt;函数间隔&amp;amp;几何间隔&lt;/h2&gt;&lt;p&gt;超平面关于样本点的函数间隔$\hat{\gamma_i} = y_i(w\cdot x_i + b)$，关于训练集额函数间隔为$\hat{\gamma} = \min_{i = 1, \dots, N}\hat{\gamma_{i}}$。&lt;/p&gt;
&lt;p&gt;几何间隔将其规范化，超平面关于样本点的几何间隔${\gamma_i} = y_i(\frac{w}{|w|}\cdot x_i + \frac{b}{|w|})$，关于训练集额函数间隔为${\gamma} = \min_{i = 1, \dots, N}{\gamma_{i}}$。&lt;/p&gt;
&lt;h2 id=&quot;间隔最大化&quot;&gt;&lt;a href=&quot;#间隔最大化&quot; class=&quot;headerlink&quot; title=&quot;间隔最大化&quot;&gt;&lt;/a&gt;间隔最大化&lt;/h2&gt;&lt;p&gt;SVM基本思想时求解能正确划分数据集并且几何间隔最大的分离超平面。&lt;/p&gt;
&lt;p&gt;线性可分SVM可以转化成如下最优化问题&lt;br&gt;$$&lt;br&gt;\min_{w, b} \frac{1}{2}|w|^2 \ \textrm{s.t.}\ y_i(w \cdot x_i + b) - 1 \ge 0&lt;br&gt;$$&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://luciusssss.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>统计学习方法笔记4 决策树</title>
    <link href="http://luciusssss.github.io/2020/03/29/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B04-%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <id>http://luciusssss.github.io/2020/03/29/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B04-%E5%86%B3%E7%AD%96%E6%A0%91/</id>
    <published>2020-03-29T08:37:44.000Z</published>
    <updated>2020-08-03T11:13:44.721Z</updated>
    
    <content type="html"><![CDATA[<p>分类决策树由节点和有向边组成，内部节点表示一种特征或属性，叶节点表示分类。决策时学习主要有三个步骤：特征选择、决策树生成和决策树修建。</p><p>决策树本质是从训练数据中归纳出一组分类规则。我们需要一个与训练数据矛盾较小的决策树，同时具有较好的泛化能力。</p><h1 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h1><p>如果特征过多，则需要对特征进行选择，只留下对于训练数据有足够分类能力的数据。如果用一个特征分类与随即分类的结果差别不大，那么这个特征是没有分类能力的。通常特征选择的准则是信息增益或信息增益比。</p><h2 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h2><p>首先给出熵的定义。熵是表示随机变量不确定性的度量。对于一个取有限个值得随机变量，概率分布为<br>$$<br>P(X = x_i) = p_i,\ i = 1, \dots, n<br>$$<br>随机变量$X$得熵为<br>$$<br>H(X) = H(p) = -\sum_{i = 1}^{n} p_i \log p_i<br>$$<br>随机变量$X$给定的条件下随机变量$Y$的条件熵为<br>$$<br>H(Y\mid X) = \sum_{i = 1}^{n } p_i H(Y | X = x_i)<br>$$<br>当熵和条件熵由数据估计得到时，分别称为经验熵和经验条件熵。</p><h2 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h2><p>信息增益表示知道特征$X$的信息而使类$Y$的信息不确定性减少的程度。</p><p>特征A对数据集D的信息增益$g(D,A)$定义为<br>$$<br>g(D, S) = H(D) - H(D\mid A)<br>$$<br>$|C_k|$为$D$中分类为$C_k$的样本数，根据特征$A$可以将$D$分成$D_1, \dots, D_n$，则<br>$$<br>H(D) = -\sum_{k = 1}^{K}\frac{|C_k|}{|D|}\log \frac{|C_k|}{|D|}<br>$$</p><p>$$<br>H(D|A) = \sum_{i=1}^{n}\frac{|D_i|}{|D|}H(D_i) = - \sum_{i=1}^{n}\frac{|D_i|}{|D|} \sum_{k=1}^{K}\frac{|D_{ik}|}{|D_i|} \log \frac{|D_{ik}|}{|D_i|}<br>$$</p><h2 id="信息增益比"><a href="#信息增益比" class="headerlink" title="信息增益比"></a>信息增益比</h2><p>以信息增益作为划分依据时，存在偏向于选择取值较多的特征的问题，可以使用信息增益比及逆行矫正。</p><p>特征$A$对于训练数据集$D$的信息增益比为信息增益于$D$关于$A$的值的熵<br>$$<br>g_{R}(D, A) = \frac{g(D, A)}{H_{A}(D)}<br>$$<br>其中$H_{A}(D) = -\sum_{i=1}^{n}\frac{|D_i|}{|D|}\log \frac{|D_i|}{|D|}$。</p><h1 id="决策树生成"><a href="#决策树生成" class="headerlink" title="决策树生成"></a>决策树生成</h1><h2 id="ID3算法"><a href="#ID3算法" class="headerlink" title="ID3算法"></a>ID3算法</h2><ol><li>若$D$总所有实例都属于$C_k$或特征集$A$为空，则设为叶子节点。</li><li>否则，选择$A$中信息增益最大的特征$A_g$。如果$A_g$信息增益小于阈值，则设为叶子节点。</li><li>否则，对$A_g$每个可能的取值，划分成非空子集当作子节点，从$A$删除该特征后对子节点递归调用。</li></ol><h2 id="C4-5算法"><a href="#C4-5算法" class="headerlink" title="C4.5算法"></a>C4.5算法</h2><p>把ID3算法中的信息增益改进成信息增益比。</p><h1 id="决策树剪枝"><a href="#决策树剪枝" class="headerlink" title="决策树剪枝"></a>决策树剪枝</h1><p>设树$T$叶子节点个数为$|T|$，叶节点$t$有$N_t$个样本点，其中类为$k$的样本点个数为$N_{tk}$，叶节点$t$的经验熵为$H_t(T)$，则可以定义以下损失函数<br>$$<br>C_{\alpha}(T) = \sum_{t=1}^{|T|}N_t H_t(T) + \alpha|T|<br>$$<br>右边第一项记为<br>$$<br>C(T) = -\sum_{t=1}^{|T|}N_t\sum_{k=1}^{K}\frac{N_{tk}}{N_t} \log \frac{N_{tk}}{N_t} = -\sum_{t=1}^{|T|}\sum_{k=1}^{K}N_{tk} \log \frac{N_{tk}}{N_t}<br>$$<br>则<br>$$<br>C_{\alpha}(T) = C(T) + \alpha |T|<br>$$<br>设一组叶节点回缩到父节点后整个树的损失减小，则进行剪枝，即将父节点变成新的叶节点。</p><h1 id="CART算法"><a href="#CART算法" class="headerlink" title="CART算法"></a>CART算法</h1><p>CART算法既可以用于分类也可用于分类，它每个内部节点进行对给定条件的是否判断，从而建立一颗二叉树。算法由生成和剪枝两部分组成。</p><h2 id="回归树生成"><a href="#回归树生成" class="headerlink" title="回归树生成"></a>回归树生成</h2><p>假设将输入空间分成$M$个单元，单元$R_m$上由固定输出值$c_m$，则回归树模型可以表示为<br>$$<br>f(x) = \sum_{m=1}^{M} c_{m} \mathrm{I}(x \in R_m)<br>$$<br>用平方误差最小的准则求解每个单元上的最优输出值得到<br>$$<br>\hat{c_m} = \mathrm{ave}(y_i\mid x_i \in R_m)<br>$$<br>选择第$j$个变量$x^{(j)}$的值$s$为切分点，可以得到两个区域<br>$$<br>R_1(j, s) = {x\mid x^{(j)} \leq s },\  R_2(j, s) = {x\mid x^{(j)} &gt; s }<br>$$<br>在生成算法中，每步选取最优的切分变量$j$和切分点$s$，即求解<br>$$<br>\min_{j, s} ( \min_{c_1}\sum_{x_i \in R_1(j,s)} (y_i - c_1)^2 + \min_{c_2}\sum_{x_i \in R_2(j,s)} (y_i - c_2)^2 )<br>$$<br>对于选定的$(j, s)$对划分区域并决定对应的输出值。</p><h2 id="分类树生成"><a href="#分类树生成" class="headerlink" title="分类树生成"></a>分类树生成</h2><p>先定义基尼指数：分类问题中，$K$个类，样本点属于第$k$类的概率为$p_k$，则<br>$$<br>\mathrm{Gini}(p) = \sum_{k=1}^{K} p_k (1-p_k) = 1 - \sum_{k=1}^{K} p_k^2<br>$$<br>如果样本集合$D$根据特征$A$是否取某一可能值$a$被分为$D_1$和$D_2$，则在特征$A$的条件下，集合$D$的基尼指数为<br>$$<br>\textrm{Gini(D, A)} = \frac{|D_1|}{|D|}\mathrm{Gini}(D_1) + \frac{|D_2|}{|D|}\mathrm{Gini}(D_2)<br>$$<br>每次确定内部节点时，选择基尼指数最小的（特征，切分点）进行划分。</p><h2 id="CART剪枝"><a href="#CART剪枝" class="headerlink" title="CART剪枝"></a>CART剪枝</h2><ol><li><p>设$k = 0, T = T_0$。</p></li><li><p>令$\alpha = + \infty$。</p></li><li><p>自下而上地对各内部节点$t$计算$C(T_t), |T_t|$和<br>$$<br>g(t) = \frac{C(t) - C(T_t)}{|T_t| - 1}<br>$$</p><p>$$<br>\alpha = \min(\alpha, g(t))<br>$$</p><p>$T_t$表示以$t$为根节点的子树。</p></li><li><p>对$g(t) = \alpha$的内部节点$t$进行剪枝，得到树$T$。（因为当$\alpha$大于$g(t)$时，剪枝会使损失函数减少，随着$\alpha$增加，总有某棵子树改剪。cart树怎么进行剪枝？ - FuriousFatty的回答 - 知乎 <a href="https://www.zhihu.com/question/22697086/answer/134841101" target="_blank" rel="noopener">https://www.zhihu.com/question/22697086/answer/134841101</a>  ）</p></li><li><p>令$k = k + 1, \alpha_k = \alpha, T_k = T$。</p></li><li><p>如果$T_k$不是由一个根节点和两个叶节点组成的树，则回到步骤2；否则令$T_k = T_n$。</p></li><li><p>使用交叉验证从$T_1, T_2, \dots, T_n$中选出最优子树$T_\alpha$。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;分类决策树由节点和有向边组成，内部节点表示一种特征或属性，叶节点表示分类。决策时学习主要有三个步骤：特征选择、决策树生成和决策树修建。&lt;/p&gt;
&lt;p&gt;决策树本质是从训练数据中归纳出一组分类规则。我们需要一个与训练数据矛盾较小的决策树，同时具有较好的泛化能力。&lt;/p&gt;
&lt;h1
      
    
    </summary>
    
    
      <category term="机器学习" scheme="http://luciusssss.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://luciusssss.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="统计学习方法" scheme="http://luciusssss.github.io/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>统计学习方法笔记3 k近邻</title>
    <link href="http://luciusssss.github.io/2020/03/28/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B03-k%E8%BF%91%E9%82%BB/"/>
    <id>http://luciusssss.github.io/2020/03/28/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B03-k%E8%BF%91%E9%82%BB/</id>
    <published>2020-03-28T01:51:42.000Z</published>
    <updated>2020-08-03T11:13:44.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="k近邻算法"><a href="#k近邻算法" class="headerlink" title="k近邻算法"></a>k近邻算法</h1><p>k近邻（KNN）是一种不需要显式训练的分类算法，在inference时对于新的实例，根据最近的k个最近邻的训练实例的类别，通过多数表决的方式进行预测。</p><a id="more"></a><h1 id="k近邻模型"><a href="#k近邻模型" class="headerlink" title="k近邻模型"></a>k近邻模型</h1><p>KNN使用的模型实际对应于特征空间的划分，对于每个训练实例点，距离该点比其他点更近的所有点组成一个区域，叫作单元，每个训练实例点拥有一个的单元，所有实例点的单元构成对特征空间的一个划分。</p><p>KNN模型由三个要素决定：距离度量，k值选择，分类决策规则。</p><h2 id="距离度量"><a href="#距离度量" class="headerlink" title="距离度量"></a>距离度量</h2><p>常用欧式距离，也可以用更一般的$L_p$距离<br>$$<br>L_p(x_i, x_y) =  (\sum_{l = 1}^{n}|x_i^{(l)} - x_j^{(l)}|^p)^{\frac{1}{p}}<br>$$<br>当$p = 1$时为曼哈顿距离；当$p=2$时为欧式距离；当$p = \infty$时为各个坐标距离的最大值。</p><h2 id="k值选择"><a href="#k值选择" class="headerlink" title="k值选择"></a>k值选择</h2><p>k值越小 $\Leftrightarrow$ 单个样本影响越大  $\Leftrightarrow$ 模型越复杂 $\Leftrightarrow$ 假设空间越大 $\Leftrightarrow$ 近似误差越小（估计误差越大），容易过拟合；</p><p>k值越大 $\Leftrightarrow$ 单个样本影响越小 $\Leftrightarrow$ 模型越简单 $\Leftrightarrow$ 假设空间越小 $\Leftrightarrow$ 近似误差越大（估计误差越小），容易欠拟合。</p><p>来自【如何理解和区分近似误差和估计误差? - mygame182的回答 - 知乎 <a href="https://www.zhihu.com/question/60793482/answer/1044887227】" target="_blank" rel="noopener">https://www.zhihu.com/question/60793482/answer/1044887227】</a></p><h2 id="分类决策规则"><a href="#分类决策规则" class="headerlink" title="分类决策规则"></a>分类决策规则</h2><p>常用多数表决规则，等价于经验风险最小化。</p><h1 id="kd树"><a href="#kd树" class="headerlink" title="kd树"></a>kd树</h1><p>与线性扫描相比，kd树能将最近邻搜索的时间复杂度从$O(N)$降到$O(\log N)$。</p><h2 id="构造平衡kd树"><a href="#构造平衡kd树" class="headerlink" title="构造平衡kd树"></a>构造平衡kd树</h2><ol><li>构造根节点，根节点对应包含数据集$T$的$k$维空间的超矩形区域。选择$x^{(1)}$坐标轴，以$T$中所有实例的该坐标的中位数为切分点，将根节点切分成两个区域。将切分点保存在该节点。</li><li>对于不同的深度的节点，依次选择不同的坐标选择中位数节点进行划分。</li><li>直到两个子区域没有实例点存在，从而形成kd树的区域划分。</li></ol><h2 id="搜索kd树"><a href="#搜索kd树" class="headerlink" title="搜索kd树"></a>搜索kd树</h2><ol><li>在kd树中找到包含目标点$x$的叶节点，以该点为“当前最近点”。</li><li>递归向上回退，在每个节点：(a)判断是否将“当前最近点”更新为该节点。(b)检查另一子节点的对应区域，是否与以$x$和最近点距离画的圆相交。如果相交，则移动到这个子节点，递归地搜索；否则，向上回退。</li><li>回退到根节点时，搜索结束。</li></ol><h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><ol><li><p>画图观察不同k值对空间划分的影响。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">K = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">X = np.array([[<span class="number">2</span>,<span class="number">3</span>], [<span class="number">5</span>,<span class="number">4</span>], [<span class="number">9</span>,<span class="number">6</span>], [<span class="number">4</span>,<span class="number">7</span>], [<span class="number">8</span>,<span class="number">1</span>], [<span class="number">7</span>,<span class="number">2</span>]])</span><br><span class="line">Y = np.array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">POS_X = []</span><br><span class="line">NEG_X = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> np.arange(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0.2</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> np.arange(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0.2</span>):</span><br><span class="line">        dist = []</span><br><span class="line">        p = np.array([i, j])</span><br><span class="line">        <span class="keyword">for</span> q <span class="keyword">in</span> X:</span><br><span class="line">            dist.append(np.linalg.norm(p-q))</span><br><span class="line">        topk = np.argsort(dist)[<span class="number">0</span>:K]</span><br><span class="line">        neg_cnt = <span class="number">0</span></span><br><span class="line">        pos_cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> topk:</span><br><span class="line">            <span class="keyword">if</span> Y[t] == <span class="number">1</span>:</span><br><span class="line">                pos_cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                neg_cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> pos_cnt &gt; neg_cnt:</span><br><span class="line">            POS_X.append([i, j])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            NEG_X.append([i, j])</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.xlim(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">plt.ylim(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> zip(X, Y):</span><br><span class="line">    <span class="keyword">if</span> y == <span class="number">1</span>:</span><br><span class="line">        plt.scatter(x[<span class="number">0</span>], x[<span class="number">1</span>], s=<span class="number">40</span>, c=<span class="string">'r'</span>, marker=<span class="string">'x'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        plt.scatter(x[<span class="number">0</span>], x[<span class="number">1</span>], s=<span class="number">40</span>, c=<span class="string">'b'</span>, marker=<span class="string">'x'</span>)</span><br><span class="line"></span><br><span class="line">POS_X = np.array(POS_X)</span><br><span class="line">NEG_X = np.array(NEG_X)</span><br><span class="line">plt.scatter(POS_X[:,<span class="number">0</span>], POS_X[:,<span class="number">1</span>], s=<span class="number">5</span>, c=<span class="string">'r'</span>, marker=<span class="string">'.'</span>)</span><br><span class="line">plt.scatter(NEG_X[:,<span class="number">0</span>], NEG_X[:,<span class="number">1</span>], s=<span class="number">5</span>, c=<span class="string">'b'</span>, marker=<span class="string">'.'</span>)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">"K=%d"</span>%(K))</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li></ol><p>   <img src="/2020/03/28/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B03-k%E8%BF%91%E9%82%BB/k=1.png" alt><br>   <img src="/2020/03/28/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B03-k%E8%BF%91%E9%82%BB/k=2.png" alt><br>   <img src="/2020/03/28/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B03-k%E8%BF%91%E9%82%BB/k=3.png" alt></p><ol start="2"><li><p>利用例题3.2构造的kd树求$x = (3, 4.5)^{T}$的最近邻点。</p><p>a. 先走到叶节点(4, 7)，当前最近点为(4, 7)</p><p>b. 走到父节点(5, 4)，更新当前最近点为(5, 4)。父节点的左子节点在圆内，于是走到(2, 3)。</p><p>c. 更新当前最近点为(2, 3)，一直回退到(7, 2)。右子节点(9, 6)也不与圆相交。结束。</p><p>所以最近邻点为(2, 3)。</p></li><li><p>参照算法3.3，写出输出为$x$的k近邻的算法。</p><p>维护一个k近邻的点集。圆的半径换成集合中的点与$x$距离的最大值。如果集合元素小于k则直接放入集合；否则，判断区域和圆是否有相交后再更新集合。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;k近邻算法&quot;&gt;&lt;a href=&quot;#k近邻算法&quot; class=&quot;headerlink&quot; title=&quot;k近邻算法&quot;&gt;&lt;/a&gt;k近邻算法&lt;/h1&gt;&lt;p&gt;k近邻（KNN）是一种不需要显式训练的分类算法，在inference时对于新的实例，根据最近的k个最近邻的训练实例的类别，通过多数表决的方式进行预测。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://luciusssss.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://luciusssss.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="统计学习方法" scheme="http://luciusssss.github.io/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>统计学习方法笔记2 感知机</title>
    <link href="http://luciusssss.github.io/2020/03/27/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B02-%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
    <id>http://luciusssss.github.io/2020/03/27/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B02-%E6%84%9F%E7%9F%A5%E6%9C%BA/</id>
    <published>2020-03-27T07:43:22.000Z</published>
    <updated>2020-08-03T11:13:44.691Z</updated>
    
    <content type="html"><![CDATA[<p>从模型-&gt;策略-&gt;算法的思路来描述感知机！</p><h1 id="感知机模型"><a href="#感知机模型" class="headerlink" title="感知机模型"></a>感知机模型</h1><p>输入空间为$\mathcal{X} \subseteq \mathbb{R}^{n}$，输出空间为$\mathcal{Y} = {+1, -1}$，从输入空间到输出空间的函数$f(x) = \mathrm{sign}(w\cdot x + b)$称为感知机。$w\cdot x + b = 0$对应特征空间$ \mathbb{R}^{n}$内的一个超平面，将特征空间分成两部分。</p><a id="more"></a><h1 id="感知机学习策略"><a href="#感知机学习策略" class="headerlink" title="感知机学习策略"></a>感知机学习策略</h1><p>假设数据集是线性可分的，感知机的学习目标是是找到一个能将正负例完全区分开的超平面。</p><p>对于损失函数，一个naive的想法是误分类点的总数，但是这个函数对于模型参数$w,b$不可导，不易优化。另一个想法是误分类点到超平面距离之和$\sum_{x_i\in M}\frac{1}{|w|}|w\cdot x_i + b|$。因为对于误分类点有$y(w\cdot x + b) &lt; 0$，所以可以把绝对值拆掉，同时省掉$w$的$L_2$范数，得到最终的损失函数为<br>$$<br>L(w, b) = - \sum_{x_i \in M} y_i(w\cdot x_i + b)<br>$$<br>其中$M$为误分类的点集。误分类点越少，误分类点离超平面越近，损失函数值越小。</p><h1 id="感知机学习算法"><a href="#感知机学习算法" class="headerlink" title="感知机学习算法"></a>感知机学习算法</h1><h2 id="原始形式"><a href="#原始形式" class="headerlink" title="原始形式"></a>原始形式</h2><p>感知机算法是误分类驱动的，可以采用随机梯度下降进行参数更新。</p><p>假设误分类点集$M$是固定的，损失函数的梯度为<br>$$<br>\nabla_{w} L(w, b) = -\sum_{x_i \in M} y_i\cdot x_i<br>$$</p><p>$$<br>\nabla_b L(w, b) = -\sum_{x_i \in M} y_i<br>$$</p><p>随机选取一个误分类点对参数进行更新<br>$$<br>w \gets w + \eta y_ix_i<br>$$</p><p>$$<br>b \gets b + \eta y_i<br>$$</p><p>其中$\eta$为学习率。</p><p>直观上看，当一个实例点被误分类，就调增超平面朝该误分类点的一侧移动。</p><p>对于参数的不同初值和不同误分类点的选取可能会得出不同的解。</p><h2 id="收敛性"><a href="#收敛性" class="headerlink" title="收敛性"></a>收敛性</h2><p>（以下分析把参数$b$合并到$w$中，同时特征向量里添加一个1）</p><p>由于训练集是线性可分的，所以存在一个超平面$w_{opt}$满足$|w_{opt}| = 1$能将数据集完全分开。取$\gamma = \min_{i} y_i(w_{opt}\cdot x_i)$，则有对所有$i = 1, \dots, N$，有$y_i(w_{opt}\cdot x_i) \geq \gamma$。</p><p>令$R = \max_{i}|x_i|$，$w_0 = 0$。若$(x_i, y_i)$为第$k$个被误分类的数据，梯度更新得到$w_k = w_{k-1} + \eta y_i x_i$。</p><p>一方面，$w_k \cdot w_{opt} = (w_{k-1} + \eta y_i x_i)w_{opt} \geq w_{k-1}w_{opt} + \eta \gamma \geq \dots \geq k\eta \gamma$。</p><p> 另一方面有，$|w_{k}|^{2} = |w_{k-1}|^{2} + 2\eta y_i w_{k-1}\cdot x_i + \eta^2|x_i|^2 \leq |w_{k-1}|^{2} + \eta^2 R^2 \leq \dots \leq k\eta^2R^2$ 。</p><p>所以有<br>$$<br>k\eta \gamma\leq w_k \cdot w_{opt} \leq |w_{k}||w_{opt}| \leq \sqrt{k} \eta R<br>$$<br>从而得到<br>$$<br>k \leq (\frac{R}{\gamma})^2<br>$$<br>感知机算法的原始形式迭代是收敛的！</p><h2 id="对偶形式"><a href="#对偶形式" class="headerlink" title="对偶形式"></a>对偶形式</h2><p>基本想法是将$w,b$表示为$x_i, y_i$线性组合的形式（这也是SVM的基本思想）。</p><p>不妨将$w,b$初始设为0。对于误分类点$(x_i, y_i)$通过梯度更新$n_i$次，相当于对$w$加了$n_i$次$\eta y_i x_i$，对$b$加了$n_i$次$\eta y_i$。l令$\alpha_i = n_i\eta$这样最后学到的$w,b$可以表示成<br>$$<br>w = \sum_{i=1}^{N} \alpha_i y_i x_i<br>$$</p><p>$$<br>b = \sum_{i=0}^{N}\alpha_i y_i<br>$$</p><p>当$\eta = 1$时，$\alpha_i$相当于这个实例点因为误分类而更新的次数。</p><p>在对偶形式的算法中，如果$y_i(\sum_{j=1}^{N} \alpha_j y_j x_j \cdot x_i + b) \leq 0$，则进行如下更新<br>$$<br>a_i \gets a_i + \eta<br>$$</p><p>$$<br>b \gets b + \eta y_i<br>$$</p><p>训练实例仅以内积出现，所以可以预先计算出所有内积储存为矩阵，也就是Gram矩阵<br>$$<br>\mathbf{G} = [x_i \cdot x_j]_{N\times N}<br>$$</p><h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><ol><li><p>验证感知机为什么不能表示异或。</p><p>对于两个元素的异或，有四种情况$(1, 1) \to 0$, $(1, 0) \to 1$，$(0,1)\to 1$，$(0, 0) \to 0$。而这四个点放到平面上，不是线性可分的。</p></li><li><p>构建从数据集求解感知机模型的例子。</p><p>例2.1 Python实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">InnerProduct</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> zip(a, b):</span><br><span class="line">        res += i*j</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">X = [[<span class="number">3</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">1</span>]]</span><br><span class="line">Y = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">iteration = <span class="number">10</span></span><br><span class="line">eta = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">w = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">b = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> it <span class="keyword">in</span> range(iteration):</span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(X, Y):</span><br><span class="line">        <span class="keyword">if</span> y * (InnerProduct(w, x) + b) &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(len(w)):</span><br><span class="line">                w[k] += eta * y * x[k]</span><br><span class="line">            b += eta * y</span><br><span class="line"></span><br><span class="line">all_seperated = <span class="literal">True</span></span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> zip(X, Y):</span><br><span class="line">    <span class="keyword">if</span> y * (InnerProduct(w, x) + b) &lt;= <span class="number">0</span>:</span><br><span class="line">        all_seperated = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> all_seperated:</span><br><span class="line">    print(<span class="string">'Hyperplane found!'</span>)</span><br><span class="line">    print(<span class="string">'w:'</span>, w, <span class="string">"b:"</span>, b)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'Hyperplane not found...'</span>)</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>证明：样本集线性可分的充要条件是正实例点集构成的凸壳和负实例点集构成的凸壳互不相交。定义$S = {x_1, \dots, x_k}$的凸壳$\mathrm{conv}(S) = {x = \sum_{i=1}^{k}\lambda_ix_i \mid \sum_{i =1}^{k}\lambda_i = 1, \lambda_i \geq 0, i = 1, \dots, k}$</p><p>设正例有$x_{p_1},  \dots, x_{p_k}$，负例有 $x_{q_1},  \dots, x_{q_m}$</p><p>($\Rightarrow$)</p><p>反证：假设正负点集的凸壳相交，即存在点$x_t$满足$x_t = \sum_{i = p_1}^{p_k} \lambda_i x_i = \sum_{j = q_1}^{q_m} \lambda_j x_j$。因为样本集线性可分，所以存在$w, b$使得对所有正例有$w\cdot x + b &gt; 0$，所有负例有$w \cdot x + b &lt; 0$。从而有$\sum_{i = p_1}^{p_k}\lambda_i (w \cdot x_i + b) = w \cdot x_t + b &gt; 0$。同理有$w\cdot x_t + b &lt; 0$ ，矛盾！</p><p>($\Leftarrow$)</p><p>直观上，凸壳不交则凸壳线性可分，从而正负点集线性可分。严谨的证明见<a href="https://blog.csdn.net/y954877035/article/details/52210734" target="_blank" rel="noopener">https://blog.csdn.net/y954877035/article/details/52210734</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从模型-&amp;gt;策略-&amp;gt;算法的思路来描述感知机！&lt;/p&gt;
&lt;h1 id=&quot;感知机模型&quot;&gt;&lt;a href=&quot;#感知机模型&quot; class=&quot;headerlink&quot; title=&quot;感知机模型&quot;&gt;&lt;/a&gt;感知机模型&lt;/h1&gt;&lt;p&gt;输入空间为$\mathcal{X} \subseteq \mathbb{R}^{n}$，输出空间为$\mathcal{Y} = {+1, -1}$，从输入空间到输出空间的函数$f(x) = \mathrm{sign}(w\cdot x + b)$称为感知机。$w\cdot x + b = 0$对应特征空间$ \mathbb{R}^{n}$内的一个超平面，将特征空间分成两部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://luciusssss.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://luciusssss.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="统计学习方法" scheme="http://luciusssss.github.io/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>统计学习方法笔记1 概论</title>
    <link href="http://luciusssss.github.io/2020/03/27/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B01-%E6%A6%82%E8%AE%BA/"/>
    <id>http://luciusssss.github.io/2020/03/27/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B01-%E6%A6%82%E8%AE%BA/</id>
    <published>2020-03-27T02:45:47.000Z</published>
    <updated>2020-08-03T11:13:44.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="统计学习的分类"><a href="#统计学习的分类" class="headerlink" title="统计学习的分类"></a>统计学习的分类</h1><h2 id="基本分类"><a href="#基本分类" class="headerlink" title="基本分类"></a>基本分类</h2><h3 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h3><ul><li>本质是学习输入到输出映射的统计规律。</li><li>假设输入与输出的随机变量$X$和$Y$遵循联合概率分布$P(X, Y)$。</li><li>模型可以表示$P(y\mid x)$或$y = f(x)$。</li></ul><h3 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h3><ul><li>本质是学习数据中的统计规律或潜在结构。</li><li>$Z$是隐式结构空间。模型可以表示成$z = g(x)$，$P(z\mid x)$或$P(x\mid z)$。前两者用于聚类和降维，最后一个用于概率估计。</li></ul><h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><ul><li>目标是长期累积的奖励最大化</li></ul><h3 id="半监督学习与主动学习"><a href="#半监督学习与主动学习" class="headerlink" title="半监督学习与主动学习"></a>半监督学习与主动学习</h3><ul><li><p>半监督拥有少量标注数据，大量未标注数据。</p></li><li><p>主动学习中机器会主动给实例让教师标注。</p></li><li><p>这两者更接近监督学习。</p></li></ul><a id="more"></a><h2 id="按模型分类"><a href="#按模型分类" class="headerlink" title="按模型分类"></a>按模型分类</h2><h3 id="概率模型与非概率模型"><a href="#概率模型与非概率模型" class="headerlink" title="概率模型与非概率模型"></a>概率模型与非概率模型</h3><ul><li>前者模型是条件概率分布的形式，后者模型是函数的形式，后者又叫确定性模型。</li><li>条件概率分布和函数可以转化：条件概率分布最大化后得到函数，函数归一化后得到条件分布。但这不是概率模型与非概率模型的区别。概率模型一定可以表示为联合概率分布的形式，而非概率模型不一定。</li></ul><h3 id="线性模型和非线性模型"><a href="#线性模型和非线性模型" class="headerlink" title="线性模型和非线性模型"></a>线性模型和非线性模型</h3><ul><li>对于非概率模型，如果$y=f(x)$或$z =g(x)$是线性函数，则称为线性模型，否则为非线性模型。</li></ul><h3 id="参数化模型和非参数化模型"><a href="#参数化模型和非参数化模型" class="headerlink" title="参数化模型和非参数化模型"></a>参数化模型和非参数化模型</h3><ul><li>前者假设模型参数的维度固定，模型可以由有限维参数完全刻画；后者假设模型参数维度不固定或者无穷尽广大，随着训练数据量的增加而增大。</li></ul><h3 id="生成模型和判别模型"><a href="#生成模型和判别模型" class="headerlink" title="生成模型和判别模型"></a>生成模型和判别模型</h3><ul><li>监督学习中，生成模型先由数据学习联合概率分布$P(X, Y)$，然后求出条件概率分布$P(Y\mid X)$。而判别模型由数据直接学习决策函数$f(X)$或条件概率分布$P(Y\mid X)$。</li><li>生成方法：学习收敛速度快；存在隐变量时也适用。</li><li>判别方法：学习准确率高；可以对数据进行各种程度的抽象、定义特征并使用特征，因此可以简化学习问题。</li></ul><h1 id="统计学习方法三要素"><a href="#统计学习方法三要素" class="headerlink" title="统计学习方法三要素"></a>统计学习方法三要素</h1><p>方法 = 模型 + 策略 + 算法</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>模型就是所要学习的条件概率分布或决策函数。模型的假设空间$\mathcal{F}$包含所有可能的条件概率分布或决策函数。</p><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>策略就是按照怎样的准则学习或选择最优模型。</p><p>使用损失函数$L(Y, f(X))$来度量输出预测$f(X)$和真实值$Y$的不一致程度。</p><p>风险函数/期望损失：<br>$$<br>R_{exp}(f) = E_P[L(Y, f(X))] = \int_{\mathcal{X}\times\mathcal{Y}}L(y, f(x))P(x, y)\mathrm{d}x\mathrm{d}y<br>$$<br>在给定训练数据集上的经验风险：<br>$$<br>R_{emp}(f) = \frac{1}{N}\sum_{i=1}^{N}L(y_i, f(x_i))<br>$$<br>当样本容量趋近于无穷时，经验风险也就趋近于期望风险，于是可以用经验风险估计期望风险。但是现实中训练样本有限，这样估计效果并不好，所以要对经验风险进行矫正。</p><p>从上可以得到两个策略</p><ul><li><p>经验风险最小化（ERM）：认为最优化模型是经验风险最小的。</p></li><li><p>结构风险最小化（SRM）：为了避免过拟合，加入模型复杂度$J(f)$的惩罚，得到结构风险<br>$$<br>R_{srm}(f) = \frac{1}{N}\sum_{i=1}^{N}L(y_i, f(x_i)) + \lambda J(f)<br>$$</p></li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>算法就是学习模型的具体计算方法。</p><h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><ol><li><p>说明伯努利模型的极大似然估计和贝叶斯估计中的统计学习方法三要素。</p><p>模型：都是在取值为0和1的随机变量上的概率分布。</p><p>策略&amp;算法：极大似然估计：<br>$$<br>\frac{\partial\ln L(p)}{\partial p} = \frac {\partial\ln \dbinom{n}{k}p^{k}(1-p)^{n-k}}{\partial p} = kp^{k-1}(1-p)^{n-k} - (n-k)p^k(1-p)^{n-k-1} = 0<br>$$<br>得到$p = \frac{k}{n}$。</p><p>贝叶斯估计：</p><p>先验地认为$p$在$[0, 1]$均匀分布，所以先验概率密度函数$f(p) = 1$。<br>$$<br>f(p \mid D) = \frac{f(D\mid \theta)f(\theta)}{f(D)}<br>$$<br>要使后验概率最大，也就要使$f(D\mid \theta)$最大。（此时贝叶斯估计和极大似然估计是可以联系起来的。）</p></li><li><p>通过经验风险最小化推导极大似然估计。证明模型是条件概率分布时，当损失函数是对数损失函数时，经验风险最小化等价于极大似然估计。</p><p>给定数据集${(x_1, y_1), \dots, (x_N, y_N)}$，各个数据独立同分布。模型$P(Y\mid X)$关于数据集的经验风险为<br>$$<br>R_{emp}(f) = \frac{1}{N} \sum_{i=1}^{N}L(y_i,P(yi\mid X)) = -\frac{1}{N}\log P(y_i\mid x)<br>$$<br>经验风险最小化就是求解最优化问题<br>$$<br>\min_{P\in \mathcal{F}}-\frac{1}{N}\log P(y_i\mid x)<br>$$<br>而对于极大似然估计，对于模型参数$\theta$，似然函数为<br>$$<br>L(\theta) = \prod_{i=1}^{N}P(y_i\mid x_i)<br>$$<br>对其取对数为<br>$$<br>\log L(\theta) = \log \prod_{i=1}^{N}P(y_i\mid x_i) = \sum_{i=1}^{N}\log P(y_i\mid x_i)<br>$$<br>要进行极大似然，也就是要<br>$$<br>\max_{\theta} \sum_{i=1}^{N}\log P(y_i\mid x_i)<br>$$<br>可以看到，经验风险最小化等价于极大似然估计。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;统计学习的分类&quot;&gt;&lt;a href=&quot;#统计学习的分类&quot; class=&quot;headerlink&quot; title=&quot;统计学习的分类&quot;&gt;&lt;/a&gt;统计学习的分类&lt;/h1&gt;&lt;h2 id=&quot;基本分类&quot;&gt;&lt;a href=&quot;#基本分类&quot; class=&quot;headerlink&quot; title=&quot;基本分类&quot;&gt;&lt;/a&gt;基本分类&lt;/h2&gt;&lt;h3 id=&quot;监督学习&quot;&gt;&lt;a href=&quot;#监督学习&quot; class=&quot;headerlink&quot; title=&quot;监督学习&quot;&gt;&lt;/a&gt;监督学习&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;本质是学习输入到输出映射的统计规律。&lt;/li&gt;
&lt;li&gt;假设输入与输出的随机变量$X$和$Y$遵循联合概率分布$P(X, Y)$。&lt;/li&gt;
&lt;li&gt;模型可以表示$P(y\mid x)$或$y = f(x)$。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;无监督学习&quot;&gt;&lt;a href=&quot;#无监督学习&quot; class=&quot;headerlink&quot; title=&quot;无监督学习&quot;&gt;&lt;/a&gt;无监督学习&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;本质是学习数据中的统计规律或潜在结构。&lt;/li&gt;
&lt;li&gt;$Z$是隐式结构空间。模型可以表示成$z = g(x)$，$P(z\mid x)$或$P(x\mid z)$。前两者用于聚类和降维，最后一个用于概率估计。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;强化学习&quot;&gt;&lt;a href=&quot;#强化学习&quot; class=&quot;headerlink&quot; title=&quot;强化学习&quot;&gt;&lt;/a&gt;强化学习&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;目标是长期累积的奖励最大化&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;半监督学习与主动学习&quot;&gt;&lt;a href=&quot;#半监督学习与主动学习&quot; class=&quot;headerlink&quot; title=&quot;半监督学习与主动学习&quot;&gt;&lt;/a&gt;半监督学习与主动学习&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;半监督拥有少量标注数据，大量未标注数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;主动学习中机器会主动给实例让教师标注。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这两者更接近监督学习。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://luciusssss.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://luciusssss.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="统计学习方法" scheme="http://luciusssss.github.io/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode二分/队列/栈专题</title>
    <link href="http://luciusssss.github.io/2020/02/20/LeetCode%E4%BA%8C%E5%88%86-%E9%98%9F%E5%88%97-%E6%A0%88%E4%B8%93%E9%A2%98/"/>
    <id>http://luciusssss.github.io/2020/02/20/LeetCode%E4%BA%8C%E5%88%86-%E9%98%9F%E5%88%97-%E6%A0%88%E4%B8%93%E9%A2%98/</id>
    <published>2020-02-20T10:23:51.000Z</published>
    <updated>2020-08-03T11:13:44.675Z</updated>
    
    <content type="html"><![CDATA[<h1 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根"></a>69. x 的平方根</h1><p>一个避免<code>x * x</code>爆int的技巧<code>x * 1ll * x</code></p><h1 id="153-Find-Minimum-in-Rotated-Sorted-Array"><a href="#153-Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="153. Find Minimum in Rotated Sorted Array"></a>153. Find Minimum in Rotated Sorted Array</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>]) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= nums[n<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid<span class="number">-1</span>] &gt; nums[mid]) <span class="keyword">return</span> nums[mid];</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="62-寻找峰值"><a href="#62-寻找峰值" class="headerlink" title="62. 寻找峰值"></a>62. 寻找峰值</h1><p>如果一个点大于其右边的点，则其及其左边一定有峰值，否则</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[mid+<span class="number">1</span>]) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="496-Next-Greater-Element-I"><a href="#496-Next-Greater-Element-I" class="headerlink" title="496. Next Greater Element I"></a>496. Next Greater Element I</h1><p>栈，找下一个更大一点的值。时间空间都是$O(n)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums2.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stk.empty() &amp;&amp; nums2[i] &gt; nums2[stk.top()])&#123;</span><br><span class="line">            m[nums2[stk.top()]] = nums2[i];</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        stk.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : nums1)&#123;</span><br><span class="line">        <span class="keyword">if</span> (m.<span class="built_in">find</span>(i) == m.<span class="built_in">end</span>()) ret.push_back(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span> ret.push_back(m[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="42-Trapping-Rain-Water"><a href="#42-Trapping-Rain-Water" class="headerlink" title="42. Trapping Rain Water"></a>42. Trapping Rain Water</h1><p>用栈的方法，见<a href="https://www.acwing.com/solution/LeetCode/content/121/" target="_blank" rel="noopener">https://www.acwing.com/solution/LeetCode/content/121/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">height</span>.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stk.empty() &amp;&amp; <span class="built_in">height</span>[i] &gt; <span class="built_in">height</span>[stk.top()])&#123;</span><br><span class="line">            <span class="keyword">int</span> top = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            <span class="keyword">if</span>(stk.empty()) <span class="keyword">break</span>;</span><br><span class="line">            ret += (i - stk.top() - <span class="number">1</span>)* (<span class="built_in">min</span>(<span class="built_in">height</span>[stk.top()], <span class="built_in">height</span>[i]) - <span class="built_in">height</span>[top]);</span><br><span class="line">        &#125;</span><br><span class="line">        stk.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="84-Largest-Rectangle-in-Histogram"><a href="#84-Largest-Rectangle-in-Histogram" class="headerlink" title="84. Largest Rectangle in Histogram"></a>84. Largest Rectangle in Histogram</h1><p>找到一个柱子左右第一个比它矮的柱子。<code>heights</code>最后加上-1为了把栈中元素全部弹出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    heights.push_back(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= heights.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stk.empty() &amp;&amp; heights[i] &lt; heights[stk.top()])&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            <span class="keyword">if</span>(stk.empty())</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, heights[cur]*i);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                ans = <span class="built_in">max</span>(ans, heights[cur]*(i - stk.top() - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        stk.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="475-供暖器"><a href="#475-供暖器" class="headerlink" title="475. 供暖器"></a>475. 供暖器</h1><p><a href="https://www.acwing.com/solution/LeetCode/content/383/" target="_blank" rel="noopener">https://www.acwing.com/solution/LeetCode/content/383/</a><br>二分再判断，时间$(m+n)\log L$。判断代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; houses, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heaters)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = heaters.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; houses.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n &amp;&amp; <span class="built_in">abs</span>(houses[i] - heaters[j]) &gt; r)</span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">if</span> (j == n)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>贪心，除去排序为线性时间。代码中有很多细节，仔细看一下。。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRadius</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; houses, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heaters)</span> </span>&#123;</span><br><span class="line">    sort(houses.<span class="built_in">begin</span>(), houses.<span class="built_in">end</span>());</span><br><span class="line">    sort(heaters.<span class="built_in">begin</span>(), heaters.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; houses.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(houses[i] - heaters[j]) &gt; r)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; heaters.<span class="built_in">size</span>() &amp;&amp; heaters[j] &lt; houses[i]) </span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">if</span> (j == heaters.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                r = <span class="built_in">max</span>(r, houses[i] - heaters[j<span class="number">-1</span>]);</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                r = <span class="built_in">max</span>(r, heaters[j] - houses[i]);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (houses[i] - heaters[j<span class="number">-1</span>] &lt; heaters[j] - houses[i])&#123;</span><br><span class="line">                    r = <span class="built_in">max</span>(r, houses[i] - heaters[j<span class="number">-1</span>]);</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                        r = <span class="built_in">max</span>(r, heaters[j] - houses[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;69-x-的平方根&quot;&gt;&lt;a href=&quot;#69-x-的平方根&quot; class=&quot;headerlink&quot; title=&quot;69. x 的平方根&quot;&gt;&lt;/a&gt;69. x 的平方根&lt;/h1&gt;&lt;p&gt;一个避免&lt;code&gt;x * x&lt;/code&gt;爆int的技巧&lt;code&gt;x * 1
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://luciusssss.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LeetCode" scheme="http://luciusssss.github.io/tags/LeetCode/"/>
    
      <category term="数据结构" scheme="http://luciusssss.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="二分" scheme="http://luciusssss.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="队列" scheme="http://luciusssss.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="栈" scheme="http://luciusssss.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode树专题</title>
    <link href="http://luciusssss.github.io/2020/02/07/LeetCode%E6%A0%91%E4%B8%93%E9%A2%98/"/>
    <id>http://luciusssss.github.io/2020/02/07/LeetCode%E6%A0%91%E4%B8%93%E9%A2%98/</id>
    <published>2020-02-07T02:37:39.000Z</published>
    <updated>2020-08-03T11:13:44.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="98-Validate-Binary-Search-Tree"><a href="#98-Validate-Binary-Search-Tree" class="headerlink" title="98. Validate Binary Search Tree"></a>98. Validate Binary Search Tree</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfs(root, INT_MIN, INT_MAX);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">long</span> <span class="keyword">long</span> minVal, <span class="keyword">long</span> <span class="keyword">long</span> maxVal)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; minVal || root-&gt;val &gt; maxVal) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> dfs(root-&gt;left, minVal, root-&gt;val<span class="number">-1l</span>l) &amp;&amp; dfs(root-&gt;right, root-&gt;val+<span class="number">1l</span>l, maxVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="94-Binary-Tree-Inorder-Traversal"><a href="#94-Binary-Tree-Inorder-Traversal" class="headerlink" title="94. Binary Tree Inorder Traversal"></a>94. Binary Tree Inorder Traversal</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* p = root;</span><br><span class="line"><span class="keyword">while</span>(p || stk.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="keyword">while</span> (p)&#123;</span><br><span class="line">        stk.push(p);</span><br><span class="line">        p = p-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    p = stk.top();</span><br><span class="line">    stk.pop();</span><br><span class="line">    ret.push_back(p-&gt;val);</span><br><span class="line">    p = p-&gt;right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="144-Binary-Tree-Preorder-Traversal"><a href="#144-Binary-Tree-Preorder-Traversal" class="headerlink" title="144. Binary Tree Preorder Traversal"></a>144. Binary Tree Preorder Traversal</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* p = root;</span><br><span class="line"><span class="keyword">while</span>(p || stk.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        ret.push_back(p-&gt;val);</span><br><span class="line">        stk.push(p-&gt;right);</span><br><span class="line">        p = p-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    p = stk.top();</span><br><span class="line">    stk.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="145-Binary-Tree-Postorder-Traversal"><a href="#145-Binary-Tree-Postorder-Traversal" class="headerlink" title="145. Binary Tree Postorder Traversal"></a>145. Binary Tree Postorder Traversal</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;pair&lt;TreeNode*, <span class="keyword">bool</span>&gt;&gt; stk;</span><br><span class="line">TreeNode* p = root;</span><br><span class="line"><span class="keyword">while</span>(p || stk.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        stk.push(&#123;p, <span class="literal">true</span>&#125;);</span><br><span class="line">        p = p-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    p = stk.top().first;</span><br><span class="line">    <span class="keyword">int</span> backFromLeft = stk.top().second;</span><br><span class="line">    stk.pop();</span><br><span class="line">    <span class="keyword">if</span> (backFromLeft) &#123;</span><br><span class="line">        stk.push(&#123;p, <span class="literal">false</span>&#125;);</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ret.push_back(p-&gt;val);</span><br><span class="line">        p = <span class="literal">NULL</span>;  <span class="comment">// 别忘了把p设为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a>101. Symmetric Tree</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> check(root-&gt;left, root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode* rl, TreeNode* rr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!rl || !rr) <span class="keyword">return</span> !rl &amp;&amp; !rr;</span><br><span class="line">    <span class="keyword">return</span> rl-&gt;val == rr-&gt;val &amp;&amp; check(rl-&gt;right, rr-&gt;left) &amp;&amp; check(rl-&gt;left, rr-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123; <span class="comment">// 中序遍历 + 逆中序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; stkl;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; stkr;</span><br><span class="line">    TreeNode* pl = root-&gt;left;</span><br><span class="line">    TreeNode* pr = root-&gt;right;</span><br><span class="line">    <span class="keyword">while</span>(pl || pr || stkl.<span class="built_in">size</span>() || stkr.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">while</span> (pl &amp;&amp; pr)&#123;</span><br><span class="line">            stkl.push(pl);</span><br><span class="line">            pl = pl-&gt;left;</span><br><span class="line">            stkr.push(pr);</span><br><span class="line">            pr = pr-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pl || pr) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pl = stkl.top();</span><br><span class="line">        stkl.pop();</span><br><span class="line">        pr = stkr.top();</span><br><span class="line">        stkr.pop();</span><br><span class="line">        <span class="keyword">if</span> (pl-&gt;val != pr-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pl = pl-&gt;right;</span><br><span class="line">        pr = pr-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a>105. Construct Binary Tree from Preorder and Inorder Traversal</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pos;</span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = inorder.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        pos[inorder[i]] = i;</span><br><span class="line">    TreeNode* root = build(preorder, inorder, <span class="number">0</span>, n<span class="number">-1</span>, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> preLeft, <span class="keyword">int</span> preRight, <span class="keyword">int</span> inLeft, <span class="keyword">int</span> inRight)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preLeft &gt; preRight) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode(preorder[preLeft]);</span><br><span class="line">    <span class="keyword">int</span> k = pos[preorder[preLeft]] - inLeft;</span><br><span class="line">    root-&gt;left = build(preorder, inorder, preLeft+<span class="number">1</span>, preLeft+k, inLeft, inLeft+k<span class="number">-1</span>);</span><br><span class="line">    root-&gt;right = build(preorder, inorder, preLeft+k+<span class="number">1</span>, preRight, inLeft+k+<span class="number">1</span>, inRight);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="543-Diameter-of-Binary-Tree"><a href="#543-Diameter-of-Binary-Tree" class="headerlink" title="543. Diameter of Binary Tree"></a>543. Diameter of Binary Tree</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maxLen;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    maxLen = <span class="number">0</span>;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = dfs(root-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> right = dfs(root-&gt;right);</span><br><span class="line">    maxLen = <span class="built_in">max</span>(maxLen, left+right+<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="236. Lowest Common Ancestor of a Binary Tree"></a>236. Lowest Common Ancestor of a Binary Tree</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">    TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">    TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">    <span class="keyword">if</span> (!left) <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">if</span> (!right) <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="124-Binary-Tree-Maximum-Path-Sum"><a href="#124-Binary-Tree-Maximum-Path-Sum" class="headerlink" title="124. Binary Tree Maximum Path Sum"></a>124. Binary Tree Maximum Path Sum</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = INT_MIN;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="built_in">max</span>(<span class="number">0</span>, dfs(root-&gt;left));</span><br><span class="line">    <span class="keyword">int</span> right = <span class="built_in">max</span>(<span class="number">0</span>, dfs(root-&gt;right));</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, left + right + root-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + root-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="173-Binary-Search-Tree-Iterator"><a href="#173-Binary-Search-Tree-Iterator" class="headerlink" title="173. Binary Search Tree Iterator"></a>173. Binary Search Tree Iterator</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">    BSTIterator(TreeNode* root) &#123;</span><br><span class="line">        TreeNode* p = root;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            stk.push(p);</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** @return the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeNode* p = stk.top();</span><br><span class="line">        <span class="keyword">int</span> curNum = p-&gt;val;</span><br><span class="line">        stk.pop();</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            stk.push(p);</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curNum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !stk.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="297-Serialize-and-Deserialize-Binary-Tree"><a href="#297-Serialize-and-Deserialize-Binary-Tree" class="headerlink" title="297. Serialize and Deserialize Binary Tree"></a>297. Serialize and Deserialize Binary Tree</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="built_in">stringstream</span> ss;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        TreeNode* p = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(!p)&#123;</span><br><span class="line">            ss &lt;&lt; <span class="string">"# "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ss&lt;&lt;p-&gt;val&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            q.push(p-&gt;left);</span><br><span class="line">            q.push(p-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ss.str();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data.empty()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(data)</span></span>;</span><br><span class="line">    <span class="built_in">string</span> t;</span><br><span class="line">    ss &gt;&gt; t;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode(stoi(t));</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        TreeNode* p = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        ss &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span> (t[<span class="number">0</span>] == <span class="string">'#'</span>)</span><br><span class="line">            p-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;left = <span class="keyword">new</span> TreeNode(stoi(t));</span><br><span class="line">            q.push(p-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        ss &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span> (t[<span class="number">0</span>] == <span class="string">'#'</span>)</span><br><span class="line">            p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;right = <span class="keyword">new</span> TreeNode(stoi(t));</span><br><span class="line">            q.push(p-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;98-Validate-Binary-Search-Tree&quot;&gt;&lt;a href=&quot;#98-Validate-Binary-Search-Tree&quot; class=&quot;headerlink&quot; title=&quot;98. Validate Binary Search Tree&quot;
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://luciusssss.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LeetCode" scheme="http://luciusssss.github.io/tags/LeetCode/"/>
    
      <category term="数据结构" scheme="http://luciusssss.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://luciusssss.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode贪心专题</title>
    <link href="http://luciusssss.github.io/2020/02/06/LeetCode%E8%B4%AA%E5%BF%83%E4%B8%93%E9%A2%98/"/>
    <id>http://luciusssss.github.io/2020/02/06/LeetCode%E8%B4%AA%E5%BF%83%E4%B8%93%E9%A2%98/</id>
    <published>2020-02-06T05:15:39.000Z</published>
    <updated>2020-08-03T11:13:44.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="392-Is-Subsequence"><a href="#392-Is-Subsequence" class="headerlink" title="392. Is Subsequence"></a>392. Is Subsequence</h1><p>判断<code>s</code>是否为<code>t</code>的子序列（不一定要连续，都是字母）。直接贪心，对于<code>s</code>中的每个字符，找到<code>t</code>中的第一次出现就去匹配下一个字符。时间$O(n)$，空间$O(1)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSubsequence</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; t.<span class="built_in">size</span>() &amp;&amp; j &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span> (t[i] == s[j]) j++;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j == s.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Follow Up: 如果有大于1B个<code>s</code>要匹配呢？<br>方法一：先存下26个字母中各个字母在<code>t</code>中出现的位置，然后对于<code>t</code>的每个字母，用二分查找<code>t</code>当前位置之后第一次出现这个字母的位置。时间$O(m\log n)$，空间$O(n)$。<br>方法二：预处理直接用一个大二维数组存26个字母在<code>t</code>某一位置之后第一次出现的位置，这样用空间换时间。</p><h1 id="55-Jump-Game"><a href="#55-Jump-Game" class="headerlink" title="55. Jump Game"></a>55. Jump Game</h1><p>转换成区间覆盖，记录当前能跳到最远的距离，如果当前<code>i</code>大于当前最远距离，则返回假，否则就更新最远距离，最后判断最远距离是否包含整个数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dist = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() &amp;&amp; i &lt;= dist; i++)</span><br><span class="line">        dist = <span class="built_in">max</span>(dist, i + nums[i]);</span><br><span class="line">    <span class="keyword">return</span> dist &gt;= (<span class="keyword">int</span>)nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="45-Jump-Game-II"><a href="#45-Jump-Game-II" class="headerlink" title="45. Jump Game II"></a>45. Jump Game II</h1><p>同上题，保证能达到终点，但要返回最少步数。BFS可以这样写成很简洁的形式，时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 边界判断一下</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, <span class="built_in">step</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">int</span> max_r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++) max_r = <span class="built_in">max</span>(max_r, i+nums[i]);</span><br><span class="line">        l = r + <span class="number">1</span>, r = max_r;</span><br><span class="line">        <span class="built_in">step</span>++;</span><br><span class="line">        <span class="keyword">if</span> (r &gt;= (<span class="keyword">int</span>)nums.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">break</span>; <span class="comment">// size()返回是unsigned，为0时减1会出问题。。。所以强转一下，以后记住了。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">step</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="376-Wiggle-Subsequence"><a href="#376-Wiggle-Subsequence" class="headerlink" title="376. Wiggle Subsequence"></a>376. Wiggle Subsequence</h1><p>先去重，然后选择所有拐点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    nums.erase(unique(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">2</span>) <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.<span class="built_in">size</span>() - <span class="number">2</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i<span class="number">-1</span>] &lt; nums[i] &amp;&amp; nums[i] &gt; nums[i+<span class="number">1</span>] || nums[i<span class="number">-1</span>] &gt; nums[i] &amp;&amp; nums[i] &lt; nums[i+<span class="number">1</span>]) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="452-Minimum-Number-of-Arrows-to-Burst-Balloons"><a href="#452-Minimum-Number-of-Arrows-to-Burst-Balloons" class="headerlink" title="452. Minimum Number of Arrows to Burst Balloons"></a>452. Minimum Number of Arrows to Burst Balloons</h1><p>先按气球结尾从小达到排，再按气球开始从小达到排。然后依次在气球结尾处扎针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">1</span>] == b[<span class="number">1</span>]) <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (points.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    sort(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>, arrow = points[<span class="number">0</span>][<span class="number">1</span>]; <span class="comment">// 单独考虑第一个气球，设了一个数据点卡points[0][0]-1。。。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (points[i][<span class="number">0</span>] &gt; arrow)&#123;</span><br><span class="line">            arrow = points[i][<span class="number">1</span>];</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="406-Queue-Reconstruction-by-Height"><a href="#406-Queue-Reconstruction-by-Height" class="headerlink" title="406. Queue Reconstruction by Height"></a>406. Queue Reconstruction by Height</h1><p>见”LeetCode刷题笔记2”。</p><h1 id="402-Remove-K-Digits"><a href="#402-Remove-K-Digits" class="headerlink" title="402. Remove K Digits"></a>402. Remove K Digits</h1><p>每次在出现逆序对时才移除，因为在单调递增的子串内部移除字母只会使整个数字变大。可以用栈的思想来实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">removeKdigits</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : num)&#123;</span><br><span class="line">        <span class="keyword">while</span>(res.<span class="built_in">size</span>() &amp;&amp; res.back() &gt; c &amp;&amp; k)&#123;</span><br><span class="line">            res.pop_back();</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        res += c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(k--) res.pop_back();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; res.<span class="built_in">size</span>() &amp;&amp; res[i] == <span class="string">'0'</span>) i++;</span><br><span class="line">    <span class="keyword">if</span> (i == res.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> res.substr(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="134-Gas-Station"><a href="#134-Gas-Station" class="headerlink" title="134. Gas Station"></a>134. Gas Station</h1><p>暴力是$O(n^2)$，通过贪心降到$O(n)$。每次从<code>i</code>走到<code>j</code>时油不够了，下次起点就设为<code>j+1</code>，起点设在这之前的点都会油不够。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = gas.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i += j+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> gasLeft = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> k = (i + j)%n;</span><br><span class="line">            gasLeft += gas[k] - cost[k];</span><br><span class="line">            <span class="keyword">if</span> (gasLeft &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == n) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目由yxc大佬挑选，其视频讲解见<a href="https://www.bilibili.com/video/av32864007?t=2836&amp;p=2" target="_blank" rel="noopener">https://www.bilibili.com/video/av32864007?t=2836&amp;p=2</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;392-Is-Subsequence&quot;&gt;&lt;a href=&quot;#392-Is-Subsequence&quot; class=&quot;headerlink&quot; title=&quot;392. Is Subsequence&quot;&gt;&lt;/a&gt;392. Is Subsequence&lt;/h1&gt;&lt;p&gt;判断&lt;c
      
    
    </summary>
    
    
      <category term="算法" scheme="http://luciusssss.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://luciusssss.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="http://luciusssss.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="贪心" scheme="http://luciusssss.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记 2</title>
    <link href="http://luciusssss.github.io/2020/01/28/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-2/"/>
    <id>http://luciusssss.github.io/2020/01/28/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-2/</id>
    <published>2020-01-28T12:10:14.000Z</published>
    <updated>2020-08-03T11:13:44.690Z</updated>
    
    <content type="html"><![CDATA[<p>开始刷Top 100 Liked Questions啦！（后50题）</p><a id="more"></a><h1 id="139-Word-Break"><a href="#139-Word-Break" class="headerlink" title="139. Word Break"></a>139. Word Break</h1><p>方法一：回溯，<strong>一定要加上记忆化</strong>。时间$O(n^2)$，空间$O(n)$。<br>方法二：BFS。对于每个开始的位置，搜索会直到给定字符串的尾部结束。复杂度同上。</p><h1 id="141-Linked-List-Cycle"><a href="#141-Linked-List-Cycle" class="headerlink" title="141. Linked List Cycle"></a>141. Linked List Cycle</h1><p>双指针。时间$O(n)$，空间$O(1)$。注意快慢指针的初始化，两个都初始化成head了，然后<code>while(slow!=fast)</code>进不去。。。</p><h1 id="142-Linked-List-Cycle-II-🌟"><a href="#142-Linked-List-Cycle-II-🌟" class="headerlink" title="142. Linked List Cycle II 🌟"></a>142. Linked List Cycle II 🌟</h1><p>指针相遇后让一个指针回<code>head</code>，然后两个指针都一步一步走直到相遇。</p><h1 id="146-LRU-Cache-🌟"><a href="#146-LRU-Cache-🌟" class="headerlink" title="146. LRU Cache 🌟"></a>146. LRU Cache 🌟</h1><p>双向链表+哈希表。插入和查询都能$O(1)$。</p><h1 id="148-Sort-List-🌟"><a href="#148-Sort-List-🌟" class="headerlink" title="148. Sort List 🌟"></a>148. Sort List 🌟</h1><p>解析：<a href="https://leetcode-cn.com/problems/sort-list/solution/148-pai-xu-lian-biao-bottom-to-up-o1-kong-jian-by-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-list/solution/148-pai-xu-lian-biao-bottom-to-up-o1-kong-jian-by-/</a><br>使用自底向上的方法归并。使用cut和merge两个基本操作。链表题真是一不小心就会炸。。</p><h1 id="152-Maximum-Product-Subarray-🌟"><a href="#152-Maximum-Product-Subarray-🌟" class="headerlink" title="152. Maximum Product Subarray 🌟"></a>152. Maximum Product Subarray 🌟</h1><p>因为可能存在乘积为负的情况，所以同时记录当前最大最小值，在<code>nums[i] &lt; 0</code>时交换最大最小值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ret = INT_MIN, imax = <span class="number">1</span>, imin = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span>) swap(imax, imin);</span><br><span class="line">    imax = <span class="built_in">max</span>(imax*nums[i], nums[i]);</span><br><span class="line">    imin = <span class="built_in">min</span>(imin*nums[i], nums[i]);</span><br><span class="line">    ret = <span class="built_in">max</span>(ret, imax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="155-Min-Stack"><a href="#155-Min-Stack" class="headerlink" title="155. Min Stack"></a>155. Min Stack</h1><p>两个辅助栈，<code>stackValue</code>和<code>stackMin</code>。push时，当加入的数字小于或等于<code>stackMin.top()</code>才加入<code>stackMin</code>。</p><h1 id="160-Intersection-of-Two-Linked-Lists"><a href="#160-Intersection-of-Two-Linked-Lists" class="headerlink" title="160. Intersection of Two Linked Lists"></a>160. Intersection of Two Linked Lists</h1><p>双指针。先测两个链表长度，然后看最后是否到达同一个节点。然后两个指针回到链表头，链表较长的指针先走相差的步数，然后两个指针一起走，直到相遇在交点。</p><h1 id="169-Majority-Element"><a href="#169-Majority-Element" class="headerlink" title="169. Majority Element"></a>169. Majority Element</h1><p>题目保证了一定Majority Element出现。<br>方法一：哈希表。时间$O(n)$，空间$O(n)$。<br>方法二：排序，然后取中位数。时间$O(n\log n)$，空间$O(1)$。</p><h1 id="198-House-Robber"><a href="#198-House-Robber" class="headerlink" title="198. House Robber"></a>198. House Robber</h1><p>DP。<code>dp[i] = max(dp[i-2] + nums[i], dp[i-3]+nums[i])</code>。</p><h1 id="200-Number-of-Islands"><a href="#200-Number-of-Islands" class="headerlink" title="200. Number of Islands"></a>200. Number of Islands</h1><p>DFS。</p><h1 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a>206. Reverse Linked List</h1><p>递归：时间$O(n)$，空间$O(n)$。<br>迭代：时间$O(n)$，空间$O(1)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode *prev = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = prev;</span><br><span class="line">        prev = cur, cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="207-Course-Schedule"><a href="#207-Course-Schedule" class="headerlink" title="207. Course Schedule"></a>207. Course Schedule</h1><p>拓扑排序，BFS。时间$O(m+n)$。</p><h1 id="208-Implement-Trie-Prefix-Tree"><a href="#208-Implement-Trie-Prefix-Tree" class="headerlink" title="208. Implement Trie (Prefix Tree)"></a>208. Implement Trie (Prefix Tree)</h1><h1 id="215-Kth-Largest-Element-in-an-Array"><a href="#215-Kth-Largest-Element-in-an-Array" class="headerlink" title="215. Kth Largest Element in an Array"></a>215. Kth Largest Element in an Array</h1><p>方法一：堆。时间$O(n\log k)$，空间$O(k)$。<br>方法二：快排。时间平均$O(n)$，最坏$O(n^2)$，空间$O(n)$。</p><h1 id="221-Maximal-Square-🌟"><a href="#221-Maximal-Square-🌟" class="headerlink" title="221. Maximal Square 🌟"></a>221. Maximal Square 🌟</h1><p>方法一：DP。<code>if(matrix[i][j] == &#39;1&#39;) dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1</code>。时间$O(nm))$，空间可以压缩到$O(m)$。<br>方法二：栈。类似84，84。复杂度同上。</p><h1 id="226-Invert-Binary-Tree"><a href="#226-Invert-Binary-Tree" class="headerlink" title="226. Invert Binary Tree"></a>226. Invert Binary Tree</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode* left = invertTree(root-&gt;left);</span><br><span class="line">    TreeNode* right = invertTree(root-&gt;right);</span><br><span class="line">    root-&gt;left = right;</span><br><span class="line">    root-&gt;right = left;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="234-Palindrome-Linked-List"><a href="#234-Palindrome-Linked-List" class="headerlink" title="234. Palindrome Linked List"></a>234. Palindrome Linked List</h1><p>方法一：复制到一个数组里再判断。时间$O(n)$，空间$O(n)$。<br>方法二：从中间切开，把后一半反转（见206），再逐一比较。时间$O(n)$，空间$O(1)$。</p><h1 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree-🌟"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree-🌟" class="headerlink" title="236. Lowest Common Ancestor of a Binary Tree 🌟"></a>236. Lowest Common Ancestor of a Binary Tree 🌟</h1><p>递归，DFS。时间$O(n)$，空间$O(n)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) <span class="keyword">return</span> root;</span><br><span class="line">    TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">    TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">    <span class="keyword">if</span> (left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (left) <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (right) <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="238-Product-of-Array-Except-Self-🌟"><a href="#238-Product-of-Array-Except-Self-🌟" class="headerlink" title="238. Product of Array Except Self 🌟"></a>238. Product of Array Except Self 🌟</h1><p>左右累乘。时间$O(n)$，空间$O(1)$（如果不算返回的数组）。</p><h1 id="239-Sliding-Window-Maximum-🌟"><a href="#239-Sliding-Window-Maximum-🌟" class="headerlink" title="239. Sliding Window Maximum 🌟"></a>239. Sliding Window Maximum 🌟</h1><p>双端队列。时间$O(n)$。deque种元素递减。更新时，先检查合法性，再检查单调性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty() &amp;&amp; i - q.front() &gt;= k)</span><br><span class="line">        q.pop_front();</span><br><span class="line">    <span class="keyword">while</span> (!q.empty() &amp;&amp; nums[i] &gt;= nums[q.back()])</span><br><span class="line">        q.pop_back();</span><br><span class="line">    q.push_back(i);</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= k<span class="number">-1</span>) ret.push_back(nums[q.front()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用堆的话，在大小为k的堆里插入元素时间为$O(\log k)$，所以总时间为$O(n\log k)$。</p><h1 id="240-Search-a-2D-Matrix-II-🌟"><a href="#240-Search-a-2D-Matrix-II-🌟" class="headerlink" title="240. Search a 2D Matrix II 🌟"></a>240. Search a 2D Matrix II 🌟</h1><p>从右上角开始往左往右移动。时间$O(m+n)$。</p><h1 id="279-Perfect-Squares-🌟"><a href="#279-Perfect-Squares-🌟" class="headerlink" title="279. Perfect Squares 🌟"></a>279. Perfect Squares 🌟</h1><p>BFS/DP。时间$O(n\sqrt{n})$</p><h1 id="283-Move-Zeroes-🌟"><a href="#283-Move-Zeroes-🌟" class="headerlink" title="283. Move Zeroes 🌟"></a>283. Move Zeroes 🌟</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++)</span><br><span class="line">    <span class="keyword">if</span>(nums[j] != <span class="number">0</span>) nums[i++] = nums[j];</span><br><span class="line"><span class="keyword">for</span>(; i &lt; nums.<span class="built_in">size</span>(); i++) nums[i] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h1 id="287-Find-the-Duplicate-Number-🌟"><a href="#287-Find-the-Duplicate-Number-🌟" class="headerlink" title="287. Find the Duplicate Number 🌟"></a>287. Find the Duplicate Number 🌟</h1><p>转换成142处理。<code>i</code>表示<code>Node*</code>，指向的节点的<code>val</code>和<code>next</code>都是<code>nums[i]</code>。</p><h1 id="297-Serialize-and-Deserialize-Binary-Tree-🌟"><a href="#297-Serialize-and-Deserialize-Binary-Tree-🌟" class="headerlink" title="297. Serialize and Deserialize Binary Tree 🌟"></a>297. Serialize and Deserialize Binary Tree 🌟</h1><p>可以DFS（先序遍历）和BFS（层次遍历）。注意stringstream的用法。在遇到NULL时，在字符串中加#。<br>题解：<a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/solution/liang-chong-jie-fa-by-jason-2-13/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/solution/liang-chong-jie-fa-by-jason-2-13/</a></p><h1 id="300-Longest-Increasing-Subsequence-🌟"><a href="#300-Longest-Increasing-Subsequence-🌟" class="headerlink" title="300. Longest Increasing Subsequence 🌟"></a>300. Longest Increasing Subsequence 🌟</h1><p>传统DP，时间$O(n^2)$。能够优化到到$O(n\log n)$。使用一个数组来记录长度为$i$的上升子序列最后一位数最小能到多少。<br><a href="https://www.acwing.com/solution/LeetCode/content/287/" target="_blank" rel="noopener">https://www.acwing.com/solution/LeetCode/content/287/</a></p><h1 id="301-Remove-Invalid-Parentheses"><a href="#301-Remove-Invalid-Parentheses" class="headerlink" title="301. Remove Invalid Parentheses"></a>301. Remove Invalid Parentheses</h1><p>回溯。先确定要删除多少左右括号，再进行回溯，注意合法性剪枝。时间$O(2^n)$。<br>确定删除多少左右括号的代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : s)&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'('</span>)</span><br><span class="line">        leftRemove++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (leftRemove == <span class="number">0</span>) rightRemove++;</span><br><span class="line">        <span class="keyword">else</span> leftRemove--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="309. Best Time to Buy and Sell Stock with Cooldown"></a>309. Best Time to Buy and Sell Stock with Cooldown</h1><p>DP，<code>hold</code>和<code>unhold</code>分别表示当天持有还是不持有股票。时间$O(n)$，空间$O(n)$，可以进一步压缩到$O(1)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hold[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">    unhold[i] = <span class="built_in">max</span>(hold[i<span class="number">-1</span>] + prices[i], unhold[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">        hold[i] = <span class="built_in">max</span>(hold[i<span class="number">-1</span>], - prices[i]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        hold[i] = <span class="built_in">max</span>(hold[i<span class="number">-1</span>], unhold[i<span class="number">-2</span>] - prices[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> unhold[n<span class="number">-1</span>];</span><br></pre></td></tr></table></figure><p>一个团灭所有的股票买卖问题的帖子：<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems</a></p><h1 id="312-Burst-Balloons-🌟"><a href="#312-Burst-Balloons-🌟" class="headerlink" title="312. Burst Balloons 🌟"></a>312. Burst Balloons 🌟</h1><p>解析：<a href="https://www.acwing.com/solution/LeetCode/content/297/" target="_blank" rel="noopener">https://www.acwing.com/solution/LeetCode/content/297/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= n; len++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - len + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = i + len <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= j; k++)</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i][k<span class="number">-1</span>] + nums[i<span class="number">-1</span>]*nums[k]*nums[j+<span class="number">1</span>] + dp[k+<span class="number">1</span>][j]);                </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="322-Coin-Change"><a href="#322-Coin-Change" class="headerlink" title="322. Coin Change"></a>322. Coin Change</h1><p>DP。时间$O(mn)$。</p><h1 id="337-House-Robber-III-🌟"><a href="#337-House-Robber-III-🌟" class="headerlink" title="337. House Robber III 🌟"></a>337. House Robber III 🌟</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left = dfs(root-&gt;left);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right = dfs(root-&gt;right);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(<span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    ret[<span class="number">0</span>] = <span class="built_in">max</span>(left[<span class="number">0</span>], left[<span class="number">1</span>]) + <span class="built_in">max</span>(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line">    ret[<span class="number">1</span>] = root-&gt;val + left[<span class="number">0</span>] + right[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="338-Counting-Bits"><a href="#338-Counting-Bits" class="headerlink" title="338. Counting Bits"></a>338. Counting Bits</h1><p>偶数的popcount等于它除以二结果的popcount，奇数的popcount等于比它小1的偶数的popcount加一。</p><h1 id="347-Top-K-Frequent-Elements"><a href="#347-Top-K-Frequent-Elements" class="headerlink" title="347. Top K Frequent Elements"></a>347. Top K Frequent Elements</h1><p>用哈希表维护元素出现频率，用优先队列选出最大的几个。时间$O(n + k\log n)$</p><h1 id="394-Decode-String-🌟"><a href="#394-Decode-String-🌟" class="headerlink" title="394. Decode String 🌟"></a>394. Decode String 🌟</h1><p>栈。时间空间都是$O(n)$。<br><a href="https://leetcode-cn.com/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/</a></p><h1 id="399-Evaluate-Division"><a href="#399-Evaluate-Division" class="headerlink" title="399. Evaluate Division"></a>399. Evaluate Division</h1><p>将除数被除数当作节点，进行BFS。</p><h1 id="406-Queue-Reconstruction-by-Height-🌟"><a href="#406-Queue-Reconstruction-by-Height-🌟" class="headerlink" title="406. Queue Reconstruction by Height 🌟"></a>406. Queue Reconstruction by Height 🌟</h1><p>先按$h$从高到低排，内部再按$k$从小到大排，再逐个插入新建的返回队列中。时间$O(n^2$。</p><h1 id="416-Partition-Equal-Subset-Sum"><a href="#416-Partition-Equal-Subset-Sum" class="headerlink" title="416. Partition Equal Subset Sum"></a>416. Partition Equal Subset Sum</h1><p>转换成01背包，数组里存的是bool。</p><h1 id="437-Path-Sum-III-🌟"><a href="#437-Path-Sum-III-🌟" class="headerlink" title="437. Path Sum III 🌟"></a>437. Path Sum III 🌟</h1><p>DFS。注意存下根节点到路径上距离为一定值的点个数。每次到一个点，检查路径上与它相差<code>sum</code>的点的个数。时间空间都是$O(n)$。</p><h1 id="438-Find-All-Anagrams-in-a-String-🌟"><a href="#438-Find-All-Anagrams-in-a-String-🌟" class="headerlink" title="438. Find All Anagrams in a String 🌟"></a>438. Find All Anagrams in a String 🌟</h1><p>滑动窗口，类似方法可以做3和76。时间$O(n)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, c = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(need.<span class="built_in">find</span>(s[i]) != need.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        window[s[i]]++;</span><br><span class="line">        <span class="keyword">if</span> (window[s[i]] == need[s[i]]) c++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c == need.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span> (i - j + <span class="number">1</span> == p.<span class="built_in">size</span>()) ret.push_back(j);</span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">find</span>(s[j]) != need.<span class="built_in">end</span>())&#123;</span><br><span class="line">            window[s[j]]--;</span><br><span class="line">            <span class="keyword">if</span> (window[s[j]] &lt; need[s[j]]) c--;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="448-Find-All-Numbers-Disappeared-in-an-Array"><a href="#448-Find-All-Numbers-Disappeared-in-an-Array" class="headerlink" title="448. Find All Numbers Disappeared in an Array"></a>448. Find All Numbers Disappeared in an Array</h1><p>数组内调换，将对应数放到对应的位置上，类似41。时间$O(n)$，空间$O(1)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span> (nums[nums[i]<span class="number">-1</span>] != nums[i])&#123;</span><br><span class="line">        swap(nums[i], nums[nums[i]<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>)</span><br><span class="line">        ret.push_back(i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="461-Hamming-Distance"><a href="#461-Hamming-Distance" class="headerlink" title="461. Hamming Distance"></a>461. Hamming Distance</h1><h1 id="494-Target-Sum-🌟"><a href="#494-Target-Sum-🌟" class="headerlink" title="494. Target Sum 🌟"></a>494. Target Sum 🌟</h1><p>类似416，转换成01背包。时间$O(n * {sum})$，空间$O(sum)$。</p><h1 id="538-Convert-BST-to-Greater-Tree"><a href="#538-Convert-BST-to-Greater-Tree" class="headerlink" title="538. Convert BST to Greater Tree"></a>538. Convert BST to Greater Tree</h1><p>累加递归。时间$O(n)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    convertBST(root-&gt;right);</span><br><span class="line">    root-&gt;val += sum;</span><br><span class="line">    sum = root-&gt;val;</span><br><span class="line">    convertBST(root-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="543-Diameter-of-Binary-Tree-🌟"><a href="#543-Diameter-of-Binary-Tree-🌟" class="headerlink" title="543. Diameter of Binary Tree 🌟"></a>543. Diameter of Binary Tree 🌟</h1><p>在求树的深度时，同时求直径。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maxPath = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> maxPath;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = dfs(root-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> right = dfs(root-&gt;right);</span><br><span class="line">    maxPath = <span class="built_in">max</span>(maxPath, left + right + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="560-Subarray-Sum-Equals-K-🌟"><a href="#560-Subarray-Sum-Equals-K-🌟" class="headerlink" title="560. Subarray Sum Equals K 🌟"></a>560. Subarray Sum Equals K 🌟</h1><p>累加+哈希。时间空间都是$O(n)$。</p><h1 id="581-Shortest-Unsorted-Continuous-Subarray"><a href="#581-Shortest-Unsorted-Continuous-Subarray" class="headerlink" title="581. Shortest Unsorted Continuous Subarray"></a>581. Shortest Unsorted Continuous Subarray</h1><p>寻找数组中间降序的最低的元素，然后把用这个极值确定左边排好了的范围。右边同理。时间$O(n)$，空间$O(1)$。</p><h1 id="617-Merge-Two-Binary-Trees"><a href="#617-Merge-Two-Binary-Trees" class="headerlink" title="617. Merge Two Binary Trees"></a>617. Merge Two Binary Trees</h1><h1 id="621-Task-Scheduler-🌟"><a href="#621-Task-Scheduler-🌟" class="headerlink" title="621. Task Scheduler 🌟"></a>621. Task Scheduler 🌟</h1><p>直接设计。。。<a href="https://leetcode-cn.com/problems/task-scheduler/solution/ren-wu-diao-du-qi-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/task-scheduler/solution/ren-wu-diao-du-qi-by-leetcode/</a></p><h1 id="647-Palindromic-Substrings"><a href="#647-Palindromic-Substrings" class="headerlink" title="647. Palindromic Substrings"></a>647. Palindromic Substrings</h1><p>中心扩展。时间$O(n^2)$，空间$O(1)$。</p><h1 id="739-Daily-Temperatures"><a href="#739-Daily-Temperatures" class="headerlink" title="739. Daily Temperatures"></a>739. Daily Temperatures</h1><p>栈。时间$O(n)$，空间$O(n)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(!st.empty() &amp;&amp; T[i] &gt; T[st.top()])&#123;</span><br><span class="line">        <span class="keyword">int</span> top = st.top();</span><br><span class="line">        st.pop();</span><br><span class="line">        res[top] = i - top;</span><br><span class="line">    &#125;</span><br><span class="line">    st.push(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始刷Top 100 Liked Questions啦！（后50题）&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://luciusssss.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://luciusssss.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="http://luciusssss.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记 1</title>
    <link href="http://luciusssss.github.io/2020/01/20/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-1/"/>
    <id>http://luciusssss.github.io/2020/01/20/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-1/</id>
    <published>2020-01-20T04:45:55.000Z</published>
    <updated>2020-08-03T11:13:44.689Z</updated>
    
    <content type="html"><![CDATA[<p>开始刷Top 100 Liked Questions啦！（前50题）</p><a id="more"></a><p>先列一些中文题解的网站：</p><ul><li><a href="https://www.acwing.com/solution/leetcode/" target="_blank" rel="noopener">https://www.acwing.com/solution/leetcode/</a></li><li><a href="https://leetcode.wang/" target="_blank" rel="noopener">https://leetcode.wang/</a></li></ul><h1 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h1><p>用unordered_map。O(n)</p><h1 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2. Add Two Numbers"></a>2. Add Two Numbers</h1><p>同时遍历两个链表</p><h1 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3. Longest Substring Without Repeating Characters"></a>3. Longest Substring Without Repeating Characters</h1><p>方法一：DP。计算以第i位字符位结尾的满足要求的字符串长度。$O(n^2)$。注意edge case: 长度为0字符串，长度为1字符串之类的。。。<br>方法二：滑动窗口，$O(n)$。<a href="https://leetcode.com/articles/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">https://leetcode.com/articles/longest-substring-without-repeating-characters/</a></p><h1 id="4-Median-of-Two-Sorted-Arrays-🌟"><a href="#4-Median-of-Two-Sorted-Arrays-🌟" class="headerlink" title="4. Median of Two Sorted Arrays 🌟"></a>4. Median of Two Sorted Arrays 🌟</h1><p>第一道hard题，解析见<a href="https://leetcode.com/articles/median-of-two-sorted-arrays/" target="_blank" rel="noopener">https://leetcode.com/articles/median-of-two-sorted-arrays/</a><br>复杂度为$O(\log min(m, n))$.</p><h1 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5. Longest Palindromic Substring"></a>5. Longest Palindromic Substring</h1><p>一开始想了一个O(n)的DP后来发现是错的，比如在“bananas”这个例子上。。。<br>中心扩展，分奇偶长度串。写扩展函数时，注意把string串引用比较好。时间$O(n^2)$，空间$O(n)$。<br>DP，时间$O(n^2)$，空间$O(n^2)$。<br>$O(n)$的算法，Manacher，类似KMP？之后再看。</p><h1 id="10-Regular-Expression-Matching-🌟"><a href="#10-Regular-Expression-Matching-🌟" class="headerlink" title="10. Regular Expression Matching 🌟"></a>10. Regular Expression Matching 🌟</h1><p>需要想一下的DP，O(mn)。<br>解析<a href="https://www.cnblogs.com/Jessey-Ge/p/10993447.html" target="_blank" rel="noopener">https://www.cnblogs.com/Jessey-Ge/p/10993447.html</a></p><h1 id="11-Container-With-Most-Water-🌟"><a href="#11-Container-With-Most-Water-🌟" class="headerlink" title="11. Container With Most Water 🌟"></a>11. Container With Most Water 🌟</h1><p>O(n)的方法：双指针，每次将较短的那个向内移动。</p><h1 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15. 3Sum"></a>15. 3Sum</h1><p>类似Two Sum。先排序$O(n\log n)$。固定target，然后双指针找Two Sum。总共$O(n^2)$。<br><strong>尤其注意两层循环都要把重复的去除。</strong></p><h1 id="17-Letter-Combinations-of-a-Phone-Number"><a href="#17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="17. Letter Combinations of a Phone Number"></a>17. Letter Combinations of a Phone Number</h1><p>直接枚举。vector删除第一个元素可以用<code>ret.erase(ret.begin())</code>。<strong>尤其注意边界情况！！！当输入字符串为空要单独判断！！！</strong></p><h1 id="19-Remove-Nth-Node-From-End-of-List"><a href="#19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="19. Remove Nth Node From End of List"></a>19. Remove Nth Node From End of List</h1><p>可以用双指针走一遍。 可以使用dummy指针当作链表头。</p><h1 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20. Valid Parentheses"></a>20. Valid Parentheses</h1><p>stack。但我还是没有一次bug-free。。。取stack的top的时，一定要先检查是否为空！！！</p><h1 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21. Merge Two Sorted Lists"></a>21. Merge Two Sorted Lists</h1><h1 id="22-Generate-Parentheses"><a href="#22-Generate-Parentheses" class="headerlink" title="22. Generate Parentheses"></a>22. Generate Parentheses</h1><p>回溯。一开始用了stack，其实不用。<code>leftCnt &lt; n</code>时尝试加上<code>(</code>，<code>rightCnt &lt; leftCnt</code>时尝试加上<code>)</code>。</p><h1 id="23-Merge-k-Sorted-Lists"><a href="#23-Merge-k-Sorted-Lists" class="headerlink" title="23. Merge k Sorted Lists"></a>23. Merge k Sorted Lists</h1><p>分治。时间$O(N\log k)$。注意<code>k==0</code>的情形。空间$O(1)$，两两合并可以参照<a href="https://www.geeksforgeeks.org/merge-k-sorted-linked-lists/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/merge-k-sorted-linked-lists/</a><br>优先队列，时间复杂度一样：<a href="https://blog.csdn.net/Ethan95/article/details/85195403" target="_blank" rel="noopener">https://blog.csdn.net/Ethan95/article/details/85195403</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优先队列的使用：默认是从大到小排。自定义时需要重载&lt;符号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node a, Node b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.x == b.x)<span class="keyword">return</span> a.y&gt;b.y;</span><br><span class="line">        <span class="keyword">return</span> a.x&gt;b.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;Node, <span class="built_in">vector</span>&lt;Node&gt;, cmp&gt;p;</span><br></pre></td></tr></table></figure><h1 id="31-Next-Permutation-🌟"><a href="#31-Next-Permutation-🌟" class="headerlink" title="31. Next Permutation 🌟"></a>31. Next Permutation 🌟</h1><p>有非常巧妙的时间$O(n)$，空间$O(1)$的做法：<a href="https://leetcode.com/articles/next-permutation/" target="_blank" rel="noopener">https://leetcode.com/articles/next-permutation/</a><br>首先从结尾开始找到最长的不升子序列，然后将该序列前一位数换成子序列中刚好比它大一点的数，在将子序列reverse一下。</p><h1 id="32-Longest-Valid-Parentheses-🌟"><a href="#32-Longest-Valid-Parentheses-🌟" class="headerlink" title="32. Longest Valid Parentheses 🌟"></a>32. Longest Valid Parentheses 🌟</h1><p>一道hard的DP。时间空间都是$O(n)$。解析：<a href="https://leetcode.com/articles/longest-valid-parentheses/" target="_blank" rel="noopener">https://leetcode.com/articles/longest-valid-parentheses/</a>  若当前为<code>)</code>则可能存在以当前位为结尾的有效串，分<code>))</code>和<code>()</code>讨论。<br>也可以用栈，复杂度相同。更清晰的解释：<a href="https://leetcode.wang/leetCode-32-Longest-Valid-Parentheses.html" target="_blank" rel="noopener">https://leetcode.wang/leetCode-32-Longest-Valid-Parentheses.html</a><br>时间$O(n)$的方法，可以从22题Generate Parentheses找到影子。<strong>注意要从左到右、从右到左各扫描一遍。</strong></p><h1 id="33-Search-in-Rotated-Sorted-Array-🌟"><a href="#33-Search-in-Rotated-Sorted-Array-🌟" class="headerlink" title="33. Search in Rotated Sorted Array 🌟"></a>33. Search in Rotated Sorted Array 🌟</h1><p>二分。<a href="https://www.cnblogs.com/zle1992/p/8996225.html" target="_blank" rel="noopener">https://www.cnblogs.com/zle1992/p/8996225.html</a><br>分别在左边有序和右边有序的情况下判断目标值的位置。</p><h1 id="34-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><a href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array" class="headerlink" title="34. Find First and Last Position of Element in Sorted Array"></a>34. Find First and Last Position of Element in Sorted Array</h1><p>二分。最直观的方法可以三次二分。</p><h1 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a>39. Combination Sum</h1><p>回溯。一开始我的想法是穷举每个数字可以使用的次数，但跑下来很慢。<br>后来看了一种回溯方式是，每次调函数加数字，都从已经使用过的最大的数字开始试着加，这种方法快很多。</p><h1 id="41-First-Missing-Positive-🌟"><a href="#41-First-Missing-Positive-🌟" class="headerlink" title="41. First Missing Positive 🌟"></a>41. First Missing Positive 🌟</h1><p>很tricky。。。<a href="https://www.cnblogs.com/grandyang/p/4395963.html" target="_blank" rel="noopener">https://www.cnblogs.com/grandyang/p/4395963.html</a></p><h1 id="42-Trapping-Rain-Water-🌟"><a href="#42-Trapping-Rain-Water-🌟" class="headerlink" title="42. Trapping Rain Water 🌟"></a>42. Trapping Rain Water 🌟</h1><p>DP分别计算对于每个i，左右最高的墙壁。然后在遍历一遍i，每次加上最矮墙壁高减去底高。</p><h1 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46. Permutations"></a>46. Permutations</h1><h1 id="48-Rotate-Image"><a href="#48-Rotate-Image" class="headerlink" title="48. Rotate Image"></a>48. Rotate Image</h1><p>方法一：每次四个数旋转<br>方法二：先转置，再左右翻折</p><h1 id="49-Group-Anagrams"><a href="#49-Group-Anagrams" class="headerlink" title="49. Group Anagrams"></a>49. Group Anagrams</h1><p>方法一：先对每个字符串排序，再以排序后的串为key扔进map里，$O(nk\log k)$。<br>方法二：对于每个字符串，统计每个字母出现的次数，并成一个key，$O(nk)$。<br>使用map的iterator时，注意<code>it != m.end()</code>中用不等号。</p><h1 id="53-Maximum-Subarray-🌟"><a href="#53-Maximum-Subarray-🌟" class="headerlink" title="53. Maximum Subarray 🌟"></a>53. Maximum Subarray 🌟</h1><p>DP可以时间O(n)，空间O(1).<code>dp = max(dp + nums[i], nums[i])</code><br>二分，如果要找的数组不包含 mid，然后得到左边和右边最大的值，如果要找的数组包含mid则左右扩展。$O(O\log n)$</p><h1 id="55-Jump-Game-🌟"><a href="#55-Jump-Game-🌟" class="headerlink" title="55. Jump Game 🌟"></a>55. Jump Game 🌟</h1><p>贪心，O(n)，可以转换成区间覆盖。<br><a href="https://www.acwing.com/solution/LeetCode/content/7762/" target="_blank" rel="noopener">https://www.acwing.com/solution/LeetCode/content/7762/</a></p><h1 id="56-Merge-Intervals"><a href="#56-Merge-Intervals" class="headerlink" title="56. Merge Intervals"></a>56. Merge Intervals</h1><p>区间合并。先排序，再遍历。$O(n\log n)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (ret.empty() || ret[cnt - <span class="number">1</span>][<span class="number">1</span>] &lt; intervals[i][<span class="number">0</span>])&#123;</span><br><span class="line">        ret.push_back(intervals[i]);</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret[cnt<span class="number">-1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(ret[cnt<span class="number">-1</span>][<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sort自定义排序<code>static bool cmp(const vector&lt;int&gt;&amp; a,const vector&lt;int&gt;&amp; b)</code></p><h1 id="62-Unique-Paths"><a href="#62-Unique-Paths" class="headerlink" title="62. Unique Paths"></a>62. Unique Paths</h1><p>方法一：组合数学，注意用long long，分子是从$\max(m, n)$到$m+n-2$，分母是$1$到$\min(m, n)-1$。<br>方法二：DP，时间$O(mn)$, 空间可以压到$O(\min (m,n))$。</p><h1 id="64-Minimum-Path-Sum"><a href="#64-Minimum-Path-Sum" class="headerlink" title="64. Minimum Path Sum"></a>64. Minimum Path Sum</h1><p>类似62，DP，时间$O(mn)$, 空间$O(\min (m,n))$。</p><h1 id="70-Climbing-Stairs"><a href="#70-Climbing-Stairs" class="headerlink" title="70. Climbing Stairs"></a>70. Climbing Stairs</h1><h1 id="72-Edit-Distance"><a href="#72-Edit-Distance" class="headerlink" title="72. Edit Distance"></a>72. Edit Distance</h1><p>经典DP，也没一次bug-free，把<code>word1[i-1] == word2[j-1]</code>写成了<code>word1[i] == word2[j]</code>。。。要小心。。。</p><h1 id="75-Sort-Colors"><a href="#75-Sort-Colors" class="headerlink" title="75. Sort Colors"></a>75. Sort Colors</h1><p>两种方法时间$O(n)$，空间$O(1)$。<br>方法一：两次遍历，第一次遍历统计0，1，2分别有多少个。<br>方法二：双指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= r; )&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] == <span class="number">2</span>)</span><br><span class="line">        swap(nums[i], nums[r--]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)</span><br><span class="line">        swap(nums[i++], nums[l++]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="76-Minimum-Window-Substring-🌟"><a href="#76-Minimum-Window-Substring-🌟" class="headerlink" title="76. Minimum Window Substring 🌟"></a>76. Minimum Window Substring 🌟</h1><p>滑动窗口，$O(n)$。首先用哈希表统计出T中所有字符出现的次数，再用两个指针更新答案，具体见<a href="https://www.acwing.com/solution/LeetCode/content/160/" target="_blank" rel="noopener">https://www.acwing.com/solution/LeetCode/content/160/</a></p><h1 id="78-Subsets"><a href="#78-Subsets" class="headerlink" title="78. Subsets"></a>78. Subsets</h1><h1 id="79-Word-Search"><a href="#79-Word-Search" class="headerlink" title="79. Word Search"></a>79. Word Search</h1><p>DFS，$O(n^2k^3)$。为了防止走回头路，可以暂时将当前的格子设为一个特殊字符，这样不需要额外的空间记录是否走过。</p><h1 id="84-Largest-Rectangle-in-Histogram-🌟"><a href="#84-Largest-Rectangle-in-Histogram-🌟" class="headerlink" title="84. Largest Rectangle in Histogram 🌟"></a>84. Largest Rectangle in Histogram 🌟</h1><p>类似42，用栈解决，栈里的柱子单调不减。对于当前柱子，找到左右第一个比它小的柱子，然后计算面积。在heights最后加一个-1可以把栈清空$O(n)$。<a href="https://www.acwing.com/solution/LeetCode/content/140/" target="_blank" rel="noopener">https://www.acwing.com/solution/LeetCode/content/140/</a></p><h1 id="85-Maximal-Rectangle-🌟"><a href="#85-Maximal-Rectangle-🌟" class="headerlink" title="85. Maximal Rectangle 🌟"></a>85. Maximal Rectangle 🌟</h1><p>基于84做，一行一行来，把1当作柱子。$O(mn)$。</p><h1 id="94-Binary-Tree-Inorder-Traversal"><a href="#94-Binary-Tree-Inorder-Traversal" class="headerlink" title="94. Binary Tree Inorder Traversal"></a>94. Binary Tree Inorder Traversal</h1><h1 id="96-Unique-Binary-Search-Trees"><a href="#96-Unique-Binary-Search-Trees" class="headerlink" title="96. Unique Binary Search Trees"></a>96. Unique Binary Search Trees</h1><p>DP，时间$O(n^2)$。卡塔兰数。</p><h1 id="98-Validate-Binary-Search-Tree"><a href="#98-Validate-Binary-Search-Tree" class="headerlink" title="98. Validate Binary Search Tree"></a>98. Validate Binary Search Tree</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root, TreeNode *leftMin=<span class="literal">NULL</span>,TreeNode *rightMax=<span class="literal">NULL</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(leftMin != <span class="literal">NULL</span> &amp;&amp; leftMin-&gt;val &gt;= root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(rightMax != <span class="literal">NULL</span> &amp;&amp; rightMax-&gt;val &lt;= root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root-&gt;left, leftMin, root) &amp;&amp; isValidBST(root-&gt;right, root, rightMax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a>101. Symmetric Tree</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* left, TreeNode* right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="literal">NULL</span> || right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> left-&gt;val == right-&gt;val &amp;&amp; dfs(left-&gt;left, right-&gt;right) &amp;&amp; dfs(left-&gt;right, right-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不递归用栈的：<a href="https://www.acwing.com/solution/LeetCode/content/182/" target="_blank" rel="noopener">https://www.acwing.com/solution/LeetCode/content/182/</a></p><h1 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. Binary Tree Level Order Traversal"></a>102. Binary Tree Level Order Traversal</h1><p>BFS。每层都新开一个level的队列。</p><h1 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a>104. Maximum Depth of Binary Tree</h1><h1 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-🌟"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-🌟" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal 🌟"></a>105. Construct Binary Tree from Preorder and Inorder Traversal 🌟</h1><p>可以用一个hash存inorder里每个数对应的序号，建hash table为$O(n)$，把查询的时间降到$O(1)$。总的复杂度为$O(n)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> preLeft, <span class="keyword">int</span> preRight, <span class="keyword">int</span> inLeft, <span class="keyword">int</span> inRight)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preLeft &gt; preRight) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> k = pos[preorder[preLeft]] - inLeft;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode(preorder[preLeft]);</span><br><span class="line">    root-&gt;left = dfs(preorder, inorder, preLeft+<span class="number">1</span>, preLeft+k, inLeft, inLeft+k<span class="number">-1</span>);</span><br><span class="line">    root-&gt;right = dfs(preorder, inorder, preLeft+k+<span class="number">1</span>, preRight, inLeft+k+<span class="number">1</span>, inRight);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="114-Flatten-Binary-Tree-to-Linked-List"><a href="#114-Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="114. Flatten Binary Tree to Linked List"></a>114. Flatten Binary Tree to Linked List</h1><p>时间$O(n)$，空间$O(1)$，要求原地。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    TreeNode* cur = root;</span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left)&#123;</span><br><span class="line">            TreeNode* p = cur-&gt;left;</span><br><span class="line">            <span class="keyword">while</span>(p-&gt;right) p = p-&gt;right;</span><br><span class="line">            p-&gt;right = cur-&gt;right;</span><br><span class="line">            cur-&gt;right = cur-&gt;left;</span><br><span class="line">            cur-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. Best Time to Buy and Sell Stock"></a>121. Best Time to Buy and Sell Stock</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    minPrice = <span class="built_in">min</span>(minPrice, prices[i]);</span><br><span class="line">    ret = <span class="built_in">max</span>(ret, prices[i]-minPrice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="124-Binary-Tree-Maximum-Path-Sum-🌟"><a href="#124-Binary-Tree-Maximum-Path-Sum-🌟" class="headerlink" title="124. Binary Tree Maximum Path Sum 🌟"></a>124. Binary Tree Maximum Path Sum 🌟</h1><p>遍历每个点，把它记作割点，分别计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="built_in">max</span>(<span class="number">0</span>, dfs(root-&gt;left));</span><br><span class="line">    <span class="keyword">int</span> right = <span class="built_in">max</span>(<span class="number">0</span>, dfs(root-&gt;right));</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, left+right+root-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + root-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="128-Longest-Consecutive-Sequence-🌟"><a href="#128-Longest-Consecutive-Sequence-🌟" class="headerlink" title="128. Longest Consecutive Sequence 🌟"></a>128. Longest Consecutive Sequence 🌟</h1><p>要求时间O(n)。<br>方法一：并查集，注意先用unordered_set去重。<br>方法二：建一个<code>unordered_map&lt;int, bool&gt;</code>，对于<code>nums</code>里每个元素，如果比它小一的数不存在，则一次查找比它大的数。<br>方法三：<a href="https://www.acwing.com/solution/LeetCode/content/222/" target="_blank" rel="noopener">https://www.acwing.com/solution/LeetCode/content/222/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp; x : nums)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> left = tr_right[x - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> right = tr_left[x + <span class="number">1</span>];</span><br><span class="line">    tr_left[x - left] = <span class="built_in">max</span>(tr_left[x - left], left + <span class="number">1</span> + right);</span><br><span class="line">    tr_right[x + right] = <span class="built_in">max</span>(tr_right[x + right], left + <span class="number">1</span> + right);</span><br><span class="line">    res = <span class="built_in">max</span>(res, left + <span class="number">1</span> + right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="136-Single-Number"><a href="#136-Single-Number" class="headerlink" title="136. Single Number"></a>136. Single Number</h1><p>位运算异或。时间$O(n)$，无额外空间。</p><h1 id="138-Copy-List-with-Random-Pointer"><a href="#138-Copy-List-with-Random-Pointer" class="headerlink" title="138. Copy List with Random Pointer"></a>138. Copy List with Random Pointer</h1><p>hash table。时间$O(n)$。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始刷Top 100 Liked Questions啦！（前50题）&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://luciusssss.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://luciusssss.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="http://luciusssss.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2019，我读过的论文</title>
    <link href="http://luciusssss.github.io/2020/01/11/2019%EF%BC%8C%E6%88%91%E8%AF%BB%E8%BF%87%E7%9A%84%E8%AE%BA%E6%96%87/"/>
    <id>http://luciusssss.github.io/2020/01/11/2019%EF%BC%8C%E6%88%91%E8%AF%BB%E8%BF%87%E7%9A%84%E8%AE%BA%E6%96%87/</id>
    <published>2020-01-11T07:00:13.000Z</published>
    <updated>2020-08-03T11:13:44.674Z</updated>
    
    <content type="html"><![CDATA[<p>去年开始认真读论文还是从7月开始，主要读了很多Question Answering的论文，其中又以Machine Reading Comprehension为主，大概了解了QA这个领域在做些什么。<br>这里我把去年读过的论文简单列一下。其中我觉得值得一读的论文我会打上😻。<br>阅读过程中尤其感谢LAI Yuxuan师兄的指导！</p><h2 id="Survey"><a href="#Survey" class="headerlink" title="Survey"></a>Survey</h2><ul><li><p>NEURAL READING COMPREHENSION AND BEYOND 😻<br><em>Chen Danqi</em><br>陈丹琦的博士毕业论文，一篇对MRC比较全面且易懂的综述。</p></li><li><p>Neural Machine Reading Comprehension: Methods and Trends<br><em>Shanshan Liu, Xin Zhang, Sheng Zhang, Hui Wang, Weiming Zhang</em><br>国防科大的MRC综述，一些想法很大胆，但一些地方没有讲明白。</p></li><li><p>Recent Advances in Natural Language Inference: A Survey of Benchmarks, Resources, and Approaches 😻<br><em>Shane Storks, Qiaozi Gao, Joyce Y. Chai</em><br>对于（广义的）Commonsense QA做的综述。</p></li></ul><a id="more"></a><h2 id="Machine-Reading-Comprehension-Dataset"><a href="#Machine-Reading-Comprehension-Dataset" class="headerlink" title="Machine Reading Comprehension Dataset"></a>Machine Reading Comprehension Dataset</h2><ul><li><p>SQuAD: 100,000+ Questions for Machine Comprehension of Text 😻<br><em>Pranav Rajpurkar, Jian Zhang, Konstantin Lopyrev, Percy Liang</em>, EMNLP 16<br>MRC领域最经典的数据集SQuAD。这是不含unanswerable question的1.0版本，问题来源于wikipedia，人工根据文章提问题。</p></li><li><p>Know What You Don’t Know: Unanswerable Questions for SQuAD 😻<br><em>Pranav Rajpurkar, Robin Jia, Percy Liang</em>, ACL 18<br>SQuAD 2.0，加入了大量unanswerable question</p></li><li><p>NewsQA: A Machine Comprehension Dataset<br><em>Adam Trischler, Tong Wang, Xingdi Yuan, Justin Harris, Alessandro Sordoni, Philip Bachman, Kaheer Suleman</em><br>文章来源于CNN，提问者只能看到新闻的summary points，答案从来自新闻正文，从而避免问题和文章过于相似。</p></li><li><p>ReCoRD: Bridging the Gap between Human and Machine Commonsense Reading Comprehension<br><em>Sheng Zhang, Xiaodong Liu, Jingjing Liu, Jianfeng Gao, Kevin Duh, Benjamin Van Durme</em><br>一个cloze形式的阅读理解数据集。文章是新闻的前几段，从新闻的剩余部分挑一个句子，挖掉句子中一个实体当作问题。</p></li><li><p>Natural Questions: A Benchmark for Question Answering Research 😻<br><em>Google</em>, TACL 19<br>以整个维基页面为文章，文章较长，同时标注长答案和短答案。</p></li><li><p>BoolQ: Exploring the Surprising Difficulty of Natural Yes/No Questions<br><em>Christopher Clark, Kenton Lee, Ming-Wei Chang, Tom Kwiatkowski, Michael Collins, Kristina Toutanova</em>, NAACL 19<br>研究自然产生的yes/no questions，制作了阅读理解数据集BoolQ，发现从entailment data迁移学习在它上面表现较好。</p></li><li><p>QUOREF: A Reading Comprehension Dataset with Questions Requiring Coreferential Reasoning<br><em>Pradeep Dasigi, Nelson F. Liu, Ana Marasović, Noah A. Smith, Matt Gardner</em>, EMNLP 19<br>24k extractive MRC questions, 文章来自wiki(40%的文章是电影情节概要)，需要共指消解。</p></li><li><p>DuoRC: Towards complex language understanding with paraphrased reading comprehension<br><em>Amrita Saha, Rahul Aralikatte, Mitesh M. Khapra, Karthik Sankaranarayanan</em>, ACL 18<br>基于7680对电影情节概要(一篇来自维基，一篇来自imdb)。4 challenges: 很多问题与文章的lexical overlap低；需要background knowledge和commonsense knowledge；叙述性的文章经常需要综合多句的复杂推理；包含no answer的问题。</p></li><li><p>DuReader: a Chinese Machine Reading Comprehension Dataset from Real-world Applications<br><em>Baidu</em>, ACL18<br>中文MRC数据集。</p></li></ul><h2 id="Commonsense-QA-Dataset"><a href="#Commonsense-QA-Dataset" class="headerlink" title="Commonsense QA Dataset"></a>Commonsense QA Dataset</h2><ul><li><p>COMMONSENSEQA: A Question Answering Challenge Targeting Commonsense Knowledge 😻<br><em>Alon Talmor, Jonathan Herzig, Nicholas Lourie, Jonathan Berant</em>, NAACL 19<br>基于ConceptNet做的选择题形式的常识问答。</p></li><li><p>COSMOS QA: Machine Reading Comprehension with Contextual Commonsense Reasoning 😻<br><em>Lifu Huang, Ronan Le Bras, Chandra Bhagavatula, Yejin Choi</em>, EMNLP 19<br>阅读理解形式的选择题常识问答，需要通过commonsense inference来read between the lines。</p></li></ul><h2 id="Other-QA-Dataset"><a href="#Other-QA-Dataset" class="headerlink" title="Other QA Dataset"></a>Other QA Dataset</h2><ul><li><p>GeoSQA: A Benchmark for Scenario-based Question Answering in the Geography Domain at High School<br><em>Zixian Huang, Yulin Shen, Xiao Li, Yuang Wei, Gong Cheng, Lin Zhou, Xinyu Dai, Yuzhong Qu</em>, EMNLP 19<br>高考地理题。如何处理题目中的图？</p></li><li><p>MathQA: Towards Interpretable Math Word Problem Solving with Operation-Based Formalisms<br>37,200个数学题，附有选项和解题路径。</p></li></ul><h2 id="Dataset-Analysis-amp-Model-Analysis"><a href="#Dataset-Analysis-amp-Model-Analysis" class="headerlink" title="Dataset Analysis &amp; Model Analysis"></a>Dataset Analysis &amp; Model Analysis</h2><ul><li><p>What Makes Reading Comprehension Questions Easier?<br><em>Saku Sugawara, Kentaro Inui, Satoshi Sekine, Akiko Aizawa</em>, EMNLP 18<br>分析最近的12个MRC数据集，通过启发式规则分割数据集，然后检查各自的表现，认为<em>hard questions require knowledge inference and multiple-sentence reasoning</em>。</p></li><li><p>Adversarial Examples for Evaluating Reading Comprehension Systems 😻<br><em>Robin Jia, Percy Liang</em>, EMNLP 19<br>对MRC进行反思的比较早的一篇。通过在文章结尾加上对抗性的句子能让模型回答错问题。</p></li><li><p>Do NLP Models Know Numbers? Probing Numeracy in Embeddings 😻<br><em>Eric Wallace, Yizhong Wang, Sujian Li, Sameer Singh, Matt Gardner</em>, EMNLP 19<br>研究发现state-of-the-art的QA模型在DROP上也表现出很好的numerical reasoning能力。为了理解这种能力如何产生，作者探索了各种embedding方法在list maximum, number encoding, addition三个任务上的表现。发现standard embeddings中存在着很大程度的numeracy，character-level embeddings对numeracy的表示很精确。</p></li></ul><h2 id="QA-Model"><a href="#QA-Model" class="headerlink" title="QA Model"></a>QA Model</h2><ul><li><p>Bidirectional Attention Flow for Machine Comprehension 😻<br><em>Minjoon Seo, Aniruddha Kembhavi, Ali Farhadi, Hannaneh Hajishirzi</em>, ICLR 17<br>基于文章和问题双向注意力的BiDAF模型。是MRC中基于注意力机制最经典的模型。</p></li><li><p>Latent Retrieval for Weakly Supervised Open Domain Question Answering<br><em>Kenton Lee, Ming-Wei Chang, Kristina Toutanova</em>, ACL 19<br>提了一个Open Domain QA的端到端模型。</p><p><strong>下面是对于Conversational MRC的方法：</strong></p></li><li><p>GRAPHFLOW: Exploiting Conversation Flow with Graph Neural Networks for Conversational Machine Comprehension<br><em>Yu Chen, Lingfei Wu, Mohammed J. Zaki</em><br>做conversational MRC的，捕获对话中的conversational flow：将conversational flow建模成对话中的一系列latent states。</p></li><li><p>Answering Conversational Questions on Structured Data without Logical Forms<br><em>Thomas Müller, Francesco Piccinno, Massimo Nicosia, Peter Shaw, Yasemin Altun</em>, EMNLP 19<br>搜集了 包含6k个对于维基上的半结构化表格进行询问的问题序列 的数据集，并提出了一个无需logical froms的weakly supervised semantic parsing模型。</p></li><li><p>Technical report on Conversational Question Answering<br>在CoQA上使用RoBERTa + AT(Adversarial Training) + KD(Knowledge Distillation)，达到90.4 F1。</p><p><strong>下面是对于Multi-hop MRC的方法：</strong></p></li><li><p>Token-level Dynamic Self-Attention Network for Multi-Passage Reading Comprehension<br><em>Yimeng Zhuang, Huadong Wang</em>, ACL 19<br>在token-level处理cross-passage infomation，能够动态地从序列中选取重要的token，达到speed, memory和accuracy的平衡。</p></li><li><p>Answering Complex Open-domain Questions Through Iterative Query Generation<br><em>Peng Qi, Xiaowen Lin, Leo Mehr, Zijian Wang, Christopher D. Manning</em>, EMNLP 19<br>在每一步，利用之前hop的IR结果生成一个新的自然语言query，用off-the-shelf的IR系统去retrive新的证据来回答问题。</p></li><li><p>Cognitive Graph for Multi-Hop Reading Comprehension at Scale<br><em>Ming Ding, Chang Zhou, Qibin Chen, Hongxia Yang, Jie Tang</em>, ACL 19<br>根据心理学中的Dual process theory，大脑先无意识地、隐性地、直觉地利用注意力检索相关信息(system 1)，然后有意识地、显性地、可控地进行推理(system 2)。</p><p><strong>下面是对于Commonsense QA的方法和一些引入External Knowledge的方法：</strong></p></li><li><p>Augmenting Neural Networks with First-order Logic<br><em>Tao Li, Vivek Srikumar</em>, ACL19<br>直接把一阶逻辑表示的外部知识（这里用了ConceptNet）嵌入到神经网络架构中，而仍然保持端到端的训练方式，同时依靠这些外部规则来减少对数据的依赖。</p></li><li><p>Align, Mask and Select: A Simple Method for Incorporating Commonsense Knowledge into Language Representation Models<br><em>Zhi-Xiu Ye, Qian Chen, Wen Wang, Zhen-Hua Ling</em><br>现存预训练的语言表示模型很少考虑直接将常识知识嵌入。本文用“align, mask, and select”的方法构造有关常识的数据集，并在它上面预训练BERT，从而将常识知识引入到语言表示模型。</p></li><li><p>Explicit Utilization of General Knowledge in Machine Reading Comprehension 😻<br><em>Chao Wang, Hui Jiang</em>, ACL 19<br>现有MRC模型与人类之间的gap体现在对数据的需求和抵御噪声的鲁棒性。为了缓解这两个问题，作者使用WordNet从passage-question pair中抽取词间语义关系作为general knowledge，来辅助端到端模型中的注意力机制。</p></li><li><p>Enhancing Pre-Trained Language Representations with Rich Knowledge for Machine Reading Comprehension<br><em>An Yang, Quan Wang, Jing Liu, Kai Liu, Yajuan Lyu, Hua Wu, Qiaoqiao She, Sujian Li</em>, ACL 19<br>使用WordNet和NELL两个KB作为MRC的外部知识，通过注意力机制选取需要的知识注入到BERT中，在Record和squad1.1上取得了很好的效果。</p></li><li><p>Careful Selection of Knowledge to solve Open Book Question Answering<br><em>Pratyay Banerjee, Kuntal Kumar Pal, Arindam Mitra, Chitta Baral</em><br>用比较IR的方法做OpenBookQA。</p></li><li><p>KagNet: Knowledge-Aware Graph Networks for Commonsense Reasoning 😻<br>一种类似DBQA的方法，利用ConceptNet建图做COMMONSENSEQA数据集。</p><p><strong>下面是对于Discrete Reasoning和Multi-span Extraction的方法（主要是针对DROP数据集）：</strong><br>DROP数据集答案包含多种类型：data、number、text span(s)，需要numerical operations比如adding、 sorting、counting。</p></li><li><p>A Multi-Type Multi-Span Network for Reading Comprehension that Requires Discrete Reasoning<br><em>Minghao Hu, Yuxing Peng, Zhen Huang, Dongsheng Li</em>, EMNLP 19</p></li><li><p>Giving BERT a Calculator: Finding Operations and Arguments with Reading Comprehension 😻<br><em>Google</em>, EMNLP 19</p></li><li><p>A Discrete Hard EM Approach for Weakly Supervised Question Answering<br><em>Sewon Min, Danqi Chen, Hannaneh Hajishirzi, Luke Zettlemoyer</em>, EMNLP 19</p></li><li><p>Tag-based Multi-Span Extraction in Reading Comprehension<br><em>Avia Efrat, Elad Segal, Mor Shoham</em></p><p><strong>下面是处理Unanswerable Questions的方法：</strong> </p></li><li><p>Relation Module for Non-answerable Prediction on Reading Comprehension<br><em>DiDi</em><br>通过增加relation module来提高MRC模型判断问题是否有答案的能力。</p></li></ul><h2 id="Transfer-Learning-amp-Multi-task-Learning"><a href="#Transfer-Learning-amp-Multi-task-Learning" class="headerlink" title="Transfer Learning &amp; Multi-task Learning"></a>Transfer Learning &amp; Multi-task Learning</h2><ul><li><p>MultiQA: An Empirical Investigation of Generalization and Transfer in Reading Comprehension 😻<br><em>Alon Talmor, Jonathan Berant</em>, ACL 19<br>研究各个MRC数据集能否互相泛化。实验做了很多。</p></li><li><p>Multi-task Learning with Sample Re-weighting for Machine Reading Comprehension<br><em>Yichong Xu, Xiaodong Liu, Yelong Shen, Jingjing Liu, Jianfeng Gao</em>, NAACL 19<br>通过将多个任务的数据集使用精细的采样结合在一起训练，提高模型的泛化性。</p></li><li><p>Unsupervised Domain Adaptation on Reading Comprehension<br>AAAI 20</p></li></ul><h2 id="Question-Generation"><a href="#Question-Generation" class="headerlink" title="Question Generation"></a>Question Generation</h2><ul><li>Learning to Ask Unanswerable Questions for Machine Reading Comprehension 😻<br><em>Haichao Zhu, Li Dong, Furu Wei, Wenhui Wang, Bing Qin, Ting Liu</em>, ACL 19<br>通过一种pair2sequence的方式，由可回答问题和段落生成不可回答问题。生成的不可回答问题当作data augmentation提升了BERT的表现。</li></ul><h2 id="Text-Matching"><a href="#Text-Matching" class="headerlink" title="Text Matching"></a>Text Matching</h2><ul><li><p>MIX: Multi-Channel Information Crossing for Text Matching<br><em>Tencent</em>, KDD 18<br>从多种细粒度进行文本匹配。</p></li><li><p>Enhanced LSTM for Natural Language Inference 😻<br><em>Qian Chen, Xiaodan Zhu, Zhenhua Ling, Si Wei, Hui Jiang, Diana Inkpen</em>, ACL 17<br>一个基于BiLSTM + Attention的很有效的文本匹配模型ESIM。</p></li></ul><h2 id="NLI-Dataset"><a href="#NLI-Dataset" class="headerlink" title="NLI Dataset"></a>NLI Dataset</h2><ul><li>Adversarial NLI: A New Benchmark for Natural Language Understanding 😻<br><em>Facebook</em><br>通过迭代的、对抗性的人类-模型循环，得到了一个大规模的NLI数据集。在这个新数据集上训练的模型在很多NLI数据集上达到state-of-the-art表现。这个数据集也说明了非专家标注者也能成功找到模型们的缺点。数据收集的方法可以运用于never-ending learning，可以成为一个moving target，而非一个快速饱和的静态benchmark。总得来说，解决了现存数据集benchmark longevity和robustness两个问题。</li></ul><h2 id="Story-Ending-Prediction"><a href="#Story-Ending-Prediction" class="headerlink" title="Story Ending Prediction"></a>Story Ending Prediction</h2><p>都是做Story Cloze Test这个数据集的。</p><ul><li>LSDSem 2017: Exploring Data Generation Methods for the Story Cloze Test<br>用了一个feature-based的方法，效果还挺好</li><li>Improving Language Understanding by Generative Pre-Training</li><li>A Multi-Attention based Neural Network with External Knowledge for Story Ending Predicting Task<br>用了SemLM</li><li>An RNN-based Binary Classifier for the Story Cloze Test<br>用了Skip-thought</li><li>A Simple and Effective Approach to the Story Cloze Test<br>用了Skip-thought</li><li>Story Ending Selection by Finding Hints from Pairwise Candidate Endings<br>隔壁的工作，将两个选项同时放入模型进行区分</li><li>Find a Reasonable Ending for Stories: Does Logic Relation Help the Story Cloze Test? 😻<br>AAAI 19。用NLI数据预训练，用逻辑知识辅助判断。</li><li>Narrative Modeling with Memory Chains and Semantic Supervision</li><li>Discriminative Sentence Modeling for Story Ending Prediction<br>AAAI 20</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去年开始认真读论文还是从7月开始，主要读了很多Question Answering的论文，其中又以Machine Reading Comprehension为主，大概了解了QA这个领域在做些什么。&lt;br&gt;这里我把去年读过的论文简单列一下。其中我觉得值得一读的论文我会打上😻。&lt;br&gt;阅读过程中尤其感谢LAI Yuxuan师兄的指导！&lt;/p&gt;
&lt;h2 id=&quot;Survey&quot;&gt;&lt;a href=&quot;#Survey&quot; class=&quot;headerlink&quot; title=&quot;Survey&quot;&gt;&lt;/a&gt;Survey&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NEURAL READING COMPREHENSION AND BEYOND 😻&lt;br&gt;&lt;em&gt;Chen Danqi&lt;/em&gt;&lt;br&gt;陈丹琦的博士毕业论文，一篇对MRC比较全面且易懂的综述。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Neural Machine Reading Comprehension: Methods and Trends&lt;br&gt;&lt;em&gt;Shanshan Liu, Xin Zhang, Sheng Zhang, Hui Wang, Weiming Zhang&lt;/em&gt;&lt;br&gt;国防科大的MRC综述，一些想法很大胆，但一些地方没有讲明白。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Recent Advances in Natural Language Inference: A Survey of Benchmarks, Resources, and Approaches 😻&lt;br&gt;&lt;em&gt;Shane Storks, Qiaozi Gao, Joyce Y. Chai&lt;/em&gt;&lt;br&gt;对于（广义的）Commonsense QA做的综述。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="论文" scheme="http://luciusssss.github.io/categories/%E8%AE%BA%E6%96%87/"/>
    
    
      <category term="论文" scheme="http://luciusssss.github.io/tags/%E8%AE%BA%E6%96%87/"/>
    
      <category term="QA" scheme="http://luciusssss.github.io/tags/QA/"/>
    
  </entry>
  
</feed>
