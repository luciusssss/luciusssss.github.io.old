<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog - Lucius</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://luciusssss.github.io/"/>
  <updated>2020-02-20T15:28:36.331Z</updated>
  <id>http://luciusssss.github.io/</id>
  
  <author>
    <name>Lucius</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode二分/队列/栈专题</title>
    <link href="http://luciusssss.github.io/2020/02/20/LeetCode%E4%BA%8C%E5%88%86-%E9%98%9F%E5%88%97-%E6%A0%88%E4%B8%93%E9%A2%98/"/>
    <id>http://luciusssss.github.io/2020/02/20/LeetCode%E4%BA%8C%E5%88%86-%E9%98%9F%E5%88%97-%E6%A0%88%E4%B8%93%E9%A2%98/</id>
    <published>2020-02-20T10:23:51.000Z</published>
    <updated>2020-02-20T15:28:36.331Z</updated>
    
    <content type="html"><![CDATA[<h1 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根"></a>69. x 的平方根</h1><p>一个避免<code>x * x</code>爆int的技巧<code>x * 1ll * x</code></p><h1 id="153-Find-Minimum-in-Rotated-Sorted-Array"><a href="#153-Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="153. Find Minimum in Rotated Sorted Array"></a>153. Find Minimum in Rotated Sorted Array</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>]) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= nums[n<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid<span class="number">-1</span>] &gt; nums[mid]) <span class="keyword">return</span> nums[mid];</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="62-寻找峰值"><a href="#62-寻找峰值" class="headerlink" title="62. 寻找峰值"></a>62. 寻找峰值</h1><p>如果一个点大于其右边的点，则其及其左边一定有峰值，否则</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[mid+<span class="number">1</span>]) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="496-Next-Greater-Element-I"><a href="#496-Next-Greater-Element-I" class="headerlink" title="496. Next Greater Element I"></a>496. Next Greater Element I</h1><p>栈，找下一个更大一点的值。时间空间都是$O(n)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextGreaterElement(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums2.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stk.empty() &amp;&amp; nums2[i] &gt; nums2[stk.top()])&#123;</span><br><span class="line">            m[nums2[stk.top()]] = nums2[i];</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        stk.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : nums1)&#123;</span><br><span class="line">        <span class="keyword">if</span> (m.<span class="built_in">find</span>(i) == m.<span class="built_in">end</span>()) ret.push_back(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span> ret.push_back(m[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="42-Trapping-Rain-Water"><a href="#42-Trapping-Rain-Water" class="headerlink" title="42. Trapping Rain Water"></a>42. Trapping Rain Water</h1><p>用栈的方法，见<a href="https://www.acwing.com/solution/LeetCode/content/121/" target="_blank" rel="noopener">https://www.acwing.com/solution/LeetCode/content/121/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">height</span>.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stk.empty() &amp;&amp; <span class="built_in">height</span>[i] &gt; <span class="built_in">height</span>[stk.top()])&#123;</span><br><span class="line">            <span class="keyword">int</span> top = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            <span class="keyword">if</span>(stk.empty()) <span class="keyword">break</span>;</span><br><span class="line">            ret += (i - stk.top() - <span class="number">1</span>)* (<span class="built_in">min</span>(<span class="built_in">height</span>[stk.top()], <span class="built_in">height</span>[i]) - <span class="built_in">height</span>[top]);</span><br><span class="line">        &#125;</span><br><span class="line">        stk.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="84-Largest-Rectangle-in-Histogram"><a href="#84-Largest-Rectangle-in-Histogram" class="headerlink" title="84. Largest Rectangle in Histogram"></a>84. Largest Rectangle in Histogram</h1><p>找到一个柱子左右第一个比它矮的柱子。<code>heights</code>最后加上-1为了把栈中元素全部弹出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    heights.push_back(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= heights.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stk.empty() &amp;&amp; heights[i] &lt; heights[stk.top()])&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            <span class="keyword">if</span>(stk.empty())</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, heights[cur]*i);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                ans = <span class="built_in">max</span>(ans, heights[cur]*(i - stk.top() - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        stk.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="475-供暖器"><a href="#475-供暖器" class="headerlink" title="475. 供暖器"></a>475. 供暖器</h1><p><a href="https://www.acwing.com/solution/LeetCode/content/383/" target="_blank" rel="noopener">https://www.acwing.com/solution/LeetCode/content/383/</a><br>二分再判断，时间$(m+n)\log L$。判断代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; houses, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heaters)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = heaters.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; houses.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n &amp;&amp; <span class="built_in">abs</span>(houses[i] - heaters[j]) &gt; r)</span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">if</span> (j == n)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>贪心，除去排序为线性时间。代码中有很多细节，仔细看一下。。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRadius</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; houses, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heaters)</span> </span>&#123;</span><br><span class="line">    sort(houses.<span class="built_in">begin</span>(), houses.<span class="built_in">end</span>());</span><br><span class="line">    sort(heaters.<span class="built_in">begin</span>(), heaters.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; houses.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(houses[i] - heaters[j]) &gt; r)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; heaters.<span class="built_in">size</span>() &amp;&amp; heaters[j] &lt; houses[i]) </span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">if</span> (j == heaters.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                r = <span class="built_in">max</span>(r, houses[i] - heaters[j<span class="number">-1</span>]);</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                r = <span class="built_in">max</span>(r, heaters[j] - houses[i]);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (houses[i] - heaters[j<span class="number">-1</span>] &lt; heaters[j] - houses[i])&#123;</span><br><span class="line">                    r = <span class="built_in">max</span>(r, houses[i] - heaters[j<span class="number">-1</span>]);</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                        r = <span class="built_in">max</span>(r, heaters[j] - houses[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;69-x-的平方根&quot;&gt;&lt;a href=&quot;#69-x-的平方根&quot; class=&quot;headerlink&quot; title=&quot;69. x 的平方根&quot;&gt;&lt;/a&gt;69. x 的平方根&lt;/h1&gt;&lt;p&gt;一个避免&lt;code&gt;x * x&lt;/code&gt;爆int的技巧&lt;code&gt;x * 1
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://luciusssss.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LeetCode" scheme="http://luciusssss.github.io/tags/LeetCode/"/>
    
      <category term="数据结构" scheme="http://luciusssss.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="二分" scheme="http://luciusssss.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="队列" scheme="http://luciusssss.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="栈" scheme="http://luciusssss.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode树专题</title>
    <link href="http://luciusssss.github.io/2020/02/07/LeetCode%E6%A0%91%E4%B8%93%E9%A2%98/"/>
    <id>http://luciusssss.github.io/2020/02/07/LeetCode%E6%A0%91%E4%B8%93%E9%A2%98/</id>
    <published>2020-02-07T02:37:39.000Z</published>
    <updated>2020-02-07T05:09:03.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="98-Validate-Binary-Search-Tree"><a href="#98-Validate-Binary-Search-Tree" class="headerlink" title="98. Validate Binary Search Tree"></a>98. Validate Binary Search Tree</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfs(root, INT_MIN, INT_MAX);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">long</span> <span class="keyword">long</span> minVal, <span class="keyword">long</span> <span class="keyword">long</span> maxVal)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; minVal || root-&gt;val &gt; maxVal) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> dfs(root-&gt;left, minVal, root-&gt;val<span class="number">-1l</span>l) &amp;&amp; dfs(root-&gt;right, root-&gt;val+<span class="number">1l</span>l, maxVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="94-Binary-Tree-Inorder-Traversal"><a href="#94-Binary-Tree-Inorder-Traversal" class="headerlink" title="94. Binary Tree Inorder Traversal"></a>94. Binary Tree Inorder Traversal</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* p = root;</span><br><span class="line"><span class="keyword">while</span>(p || stk.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="keyword">while</span> (p)&#123;</span><br><span class="line">        stk.push(p);</span><br><span class="line">        p = p-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    p = stk.top();</span><br><span class="line">    stk.pop();</span><br><span class="line">    ret.push_back(p-&gt;val);</span><br><span class="line">    p = p-&gt;right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="144-Binary-Tree-Preorder-Traversal"><a href="#144-Binary-Tree-Preorder-Traversal" class="headerlink" title="144. Binary Tree Preorder Traversal"></a>144. Binary Tree Preorder Traversal</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* p = root;</span><br><span class="line"><span class="keyword">while</span>(p || stk.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        ret.push_back(p-&gt;val);</span><br><span class="line">        stk.push(p-&gt;right);</span><br><span class="line">        p = p-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    p = stk.top();</span><br><span class="line">    stk.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="145-Binary-Tree-Postorder-Traversal"><a href="#145-Binary-Tree-Postorder-Traversal" class="headerlink" title="145. Binary Tree Postorder Traversal"></a>145. Binary Tree Postorder Traversal</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;pair&lt;TreeNode*, <span class="keyword">bool</span>&gt;&gt; stk;</span><br><span class="line">TreeNode* p = root;</span><br><span class="line"><span class="keyword">while</span>(p || stk.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        stk.push(&#123;p, <span class="literal">true</span>&#125;);</span><br><span class="line">        p = p-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    p = stk.top().first;</span><br><span class="line">    <span class="keyword">int</span> backFromLeft = stk.top().second;</span><br><span class="line">    stk.pop();</span><br><span class="line">    <span class="keyword">if</span> (backFromLeft) &#123;</span><br><span class="line">        stk.push(&#123;p, <span class="literal">false</span>&#125;);</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ret.push_back(p-&gt;val);</span><br><span class="line">        p = <span class="literal">NULL</span>;  <span class="comment">// 别忘了把p设为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a>101. Symmetric Tree</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> check(root-&gt;left, root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode* rl, TreeNode* rr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!rl || !rr) <span class="keyword">return</span> !rl &amp;&amp; !rr;</span><br><span class="line">    <span class="keyword">return</span> rl-&gt;val == rr-&gt;val &amp;&amp; check(rl-&gt;right, rr-&gt;left) &amp;&amp; check(rl-&gt;left, rr-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123; <span class="comment">// 中序遍历 + 逆中序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; stkl;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; stkr;</span><br><span class="line">    TreeNode* pl = root-&gt;left;</span><br><span class="line">    TreeNode* pr = root-&gt;right;</span><br><span class="line">    <span class="keyword">while</span>(pl || pr || stkl.<span class="built_in">size</span>() || stkr.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">while</span> (pl &amp;&amp; pr)&#123;</span><br><span class="line">            stkl.push(pl);</span><br><span class="line">            pl = pl-&gt;left;</span><br><span class="line">            stkr.push(pr);</span><br><span class="line">            pr = pr-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pl || pr) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pl = stkl.top();</span><br><span class="line">        stkl.pop();</span><br><span class="line">        pr = stkr.top();</span><br><span class="line">        stkr.pop();</span><br><span class="line">        <span class="keyword">if</span> (pl-&gt;val != pr-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pl = pl-&gt;right;</span><br><span class="line">        pr = pr-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a>105. Construct Binary Tree from Preorder and Inorder Traversal</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pos;</span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = inorder.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        pos[inorder[i]] = i;</span><br><span class="line">    TreeNode* root = build(preorder, inorder, <span class="number">0</span>, n<span class="number">-1</span>, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> preLeft, <span class="keyword">int</span> preRight, <span class="keyword">int</span> inLeft, <span class="keyword">int</span> inRight)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preLeft &gt; preRight) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode(preorder[preLeft]);</span><br><span class="line">    <span class="keyword">int</span> k = pos[preorder[preLeft]] - inLeft;</span><br><span class="line">    root-&gt;left = build(preorder, inorder, preLeft+<span class="number">1</span>, preLeft+k, inLeft, inLeft+k<span class="number">-1</span>);</span><br><span class="line">    root-&gt;right = build(preorder, inorder, preLeft+k+<span class="number">1</span>, preRight, inLeft+k+<span class="number">1</span>, inRight);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="543-Diameter-of-Binary-Tree"><a href="#543-Diameter-of-Binary-Tree" class="headerlink" title="543. Diameter of Binary Tree"></a>543. Diameter of Binary Tree</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maxLen;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    maxLen = <span class="number">0</span>;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = dfs(root-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> right = dfs(root-&gt;right);</span><br><span class="line">    maxLen = <span class="built_in">max</span>(maxLen, left+right+<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="236. Lowest Common Ancestor of a Binary Tree"></a>236. Lowest Common Ancestor of a Binary Tree</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">    TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">    TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">    <span class="keyword">if</span> (!left) <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">if</span> (!right) <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="124-Binary-Tree-Maximum-Path-Sum"><a href="#124-Binary-Tree-Maximum-Path-Sum" class="headerlink" title="124. Binary Tree Maximum Path Sum"></a>124. Binary Tree Maximum Path Sum</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = INT_MIN;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="built_in">max</span>(<span class="number">0</span>, dfs(root-&gt;left));</span><br><span class="line">    <span class="keyword">int</span> right = <span class="built_in">max</span>(<span class="number">0</span>, dfs(root-&gt;right));</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, left + right + root-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + root-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="173-Binary-Search-Tree-Iterator"><a href="#173-Binary-Search-Tree-Iterator" class="headerlink" title="173. Binary Search Tree Iterator"></a>173. Binary Search Tree Iterator</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">    BSTIterator(TreeNode* root) &#123;</span><br><span class="line">        TreeNode* p = root;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            stk.push(p);</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** @return the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeNode* p = stk.top();</span><br><span class="line">        <span class="keyword">int</span> curNum = p-&gt;val;</span><br><span class="line">        stk.pop();</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            stk.push(p);</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curNum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !stk.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="297-Serialize-and-Deserialize-Binary-Tree"><a href="#297-Serialize-and-Deserialize-Binary-Tree" class="headerlink" title="297. Serialize and Deserialize Binary Tree"></a>297. Serialize and Deserialize Binary Tree</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="built_in">stringstream</span> ss;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        TreeNode* p = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(!p)&#123;</span><br><span class="line">            ss &lt;&lt; <span class="string">"# "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ss&lt;&lt;p-&gt;val&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            q.push(p-&gt;left);</span><br><span class="line">            q.push(p-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ss.str();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data.empty()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(data)</span></span>;</span><br><span class="line">    <span class="built_in">string</span> t;</span><br><span class="line">    ss &gt;&gt; t;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode(stoi(t));</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        TreeNode* p = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        ss &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span> (t[<span class="number">0</span>] == <span class="string">'#'</span>)</span><br><span class="line">            p-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;left = <span class="keyword">new</span> TreeNode(stoi(t));</span><br><span class="line">            q.push(p-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        ss &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span> (t[<span class="number">0</span>] == <span class="string">'#'</span>)</span><br><span class="line">            p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;right = <span class="keyword">new</span> TreeNode(stoi(t));</span><br><span class="line">            q.push(p-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;98-Validate-Binary-Search-Tree&quot;&gt;&lt;a href=&quot;#98-Validate-Binary-Search-Tree&quot; class=&quot;headerlink&quot; title=&quot;98. Validate Binary Search Tree&quot;
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://luciusssss.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LeetCode" scheme="http://luciusssss.github.io/tags/LeetCode/"/>
    
      <category term="数据结构" scheme="http://luciusssss.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://luciusssss.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode贪心专题</title>
    <link href="http://luciusssss.github.io/2020/02/06/LeetCode%E8%B4%AA%E5%BF%83%E4%B8%93%E9%A2%98/"/>
    <id>http://luciusssss.github.io/2020/02/06/LeetCode%E8%B4%AA%E5%BF%83%E4%B8%93%E9%A2%98/</id>
    <published>2020-02-06T05:15:39.000Z</published>
    <updated>2020-02-06T13:14:43.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="392-Is-Subsequence"><a href="#392-Is-Subsequence" class="headerlink" title="392. Is Subsequence"></a>392. Is Subsequence</h1><p>判断<code>s</code>是否为<code>t</code>的子序列（不一定要连续，都是字母）。直接贪心，对于<code>s</code>中的每个字符，找到<code>t</code>中的第一次出现就去匹配下一个字符。时间$O(n)$，空间$O(1)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSubsequence</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; t.<span class="built_in">size</span>() &amp;&amp; j &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span> (t[i] == s[j]) j++;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j == s.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Follow Up: 如果有大于1B个<code>s</code>要匹配呢？<br>方法一：先存下26个字母中各个字母在<code>t</code>中出现的位置，然后对于<code>t</code>的每个字母，用二分查找<code>t</code>当前位置之后第一次出现这个字母的位置。时间$O(m\log n)$，空间$O(n)$。<br>方法二：预处理直接用一个大二维数组存26个字母在<code>t</code>某一位置之后第一次出现的位置，这样用空间换时间。</p><h1 id="55-Jump-Game"><a href="#55-Jump-Game" class="headerlink" title="55. Jump Game"></a>55. Jump Game</h1><p>转换成区间覆盖，记录当前能跳到最远的距离，如果当前<code>i</code>大于当前最远距离，则返回假，否则就更新最远距离，最后判断最远距离是否包含整个数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dist = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() &amp;&amp; i &lt;= dist; i++)</span><br><span class="line">        dist = <span class="built_in">max</span>(dist, i + nums[i]);</span><br><span class="line">    <span class="keyword">return</span> dist &gt;= (<span class="keyword">int</span>)nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="45-Jump-Game-II"><a href="#45-Jump-Game-II" class="headerlink" title="45. Jump Game II"></a>45. Jump Game II</h1><p>同上题，保证能达到终点，但要返回最少步数。BFS可以这样写成很简洁的形式，时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 边界判断一下</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, <span class="built_in">step</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">int</span> max_r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++) max_r = <span class="built_in">max</span>(max_r, i+nums[i]);</span><br><span class="line">        l = r + <span class="number">1</span>, r = max_r;</span><br><span class="line">        <span class="built_in">step</span>++;</span><br><span class="line">        <span class="keyword">if</span> (r &gt;= (<span class="keyword">int</span>)nums.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">break</span>; <span class="comment">// size()返回是unsigned，为0时减1会出问题。。。所以强转一下，以后记住了。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">step</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="376-Wiggle-Subsequence"><a href="#376-Wiggle-Subsequence" class="headerlink" title="376. Wiggle Subsequence"></a>376. Wiggle Subsequence</h1><p>先去重，然后选择所有拐点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    nums.erase(unique(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">2</span>) <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.<span class="built_in">size</span>() - <span class="number">2</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i<span class="number">-1</span>] &lt; nums[i] &amp;&amp; nums[i] &gt; nums[i+<span class="number">1</span>] || nums[i<span class="number">-1</span>] &gt; nums[i] &amp;&amp; nums[i] &lt; nums[i+<span class="number">1</span>]) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="452-Minimum-Number-of-Arrows-to-Burst-Balloons"><a href="#452-Minimum-Number-of-Arrows-to-Burst-Balloons" class="headerlink" title="452. Minimum Number of Arrows to Burst Balloons"></a>452. Minimum Number of Arrows to Burst Balloons</h1><p>先按气球结尾从小达到排，再按气球开始从小达到排。然后依次在气球结尾处扎针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">1</span>] == b[<span class="number">1</span>]) <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (points.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    sort(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>, arrow = points[<span class="number">0</span>][<span class="number">1</span>]; <span class="comment">// 单独考虑第一个气球，设了一个数据点卡points[0][0]-1。。。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (points[i][<span class="number">0</span>] &gt; arrow)&#123;</span><br><span class="line">            arrow = points[i][<span class="number">1</span>];</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="406-Queue-Reconstruction-by-Height"><a href="#406-Queue-Reconstruction-by-Height" class="headerlink" title="406. Queue Reconstruction by Height"></a>406. Queue Reconstruction by Height</h1><p>见”LeetCode刷题笔记2”。</p><h1 id="402-Remove-K-Digits"><a href="#402-Remove-K-Digits" class="headerlink" title="402. Remove K Digits"></a>402. Remove K Digits</h1><p>每次在出现逆序对时才移除，因为在单调递增的子串内部移除字母只会使整个数字变大。可以用栈的思想来实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">removeKdigits</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : num)&#123;</span><br><span class="line">        <span class="keyword">while</span>(res.<span class="built_in">size</span>() &amp;&amp; res.back() &gt; c &amp;&amp; k)&#123;</span><br><span class="line">            res.pop_back();</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        res += c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(k--) res.pop_back();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; res.<span class="built_in">size</span>() &amp;&amp; res[i] == <span class="string">'0'</span>) i++;</span><br><span class="line">    <span class="keyword">if</span> (i == res.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> res.substr(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="134-Gas-Station"><a href="#134-Gas-Station" class="headerlink" title="134. Gas Station"></a>134. Gas Station</h1><p>暴力是$O(n^2)$，通过贪心降到$O(n)$。每次从<code>i</code>走到<code>j</code>时油不够了，下次起点就设为<code>j+1</code>，起点设在这之前的点都会油不够。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = gas.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i += j+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> gasLeft = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> k = (i + j)%n;</span><br><span class="line">            gasLeft += gas[k] - cost[k];</span><br><span class="line">            <span class="keyword">if</span> (gasLeft &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == n) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目由yxc大佬挑选，其视频讲解见<a href="https://www.bilibili.com/video/av32864007?t=2836&amp;p=2" target="_blank" rel="noopener">https://www.bilibili.com/video/av32864007?t=2836&amp;p=2</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;392-Is-Subsequence&quot;&gt;&lt;a href=&quot;#392-Is-Subsequence&quot; class=&quot;headerlink&quot; title=&quot;392. Is Subsequence&quot;&gt;&lt;/a&gt;392. Is Subsequence&lt;/h1&gt;&lt;p&gt;判断&lt;c
      
    
    </summary>
    
    
      <category term="算法" scheme="http://luciusssss.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://luciusssss.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="http://luciusssss.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="贪心" scheme="http://luciusssss.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记 2</title>
    <link href="http://luciusssss.github.io/2020/01/28/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-2/"/>
    <id>http://luciusssss.github.io/2020/01/28/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-2/</id>
    <published>2020-01-28T12:10:14.000Z</published>
    <updated>2020-02-03T12:31:29.520Z</updated>
    
    <content type="html"><![CDATA[<p>开始刷Top 100 Liked Questions啦！（后50题）</p><a id="more"></a><h1 id="139-Word-Break"><a href="#139-Word-Break" class="headerlink" title="139. Word Break"></a>139. Word Break</h1><p>方法一：回溯，<strong>一定要加上记忆化</strong>。时间$O(n^2)$，空间$O(n)$。<br>方法二：BFS。对于每个开始的位置，搜索会直到给定字符串的尾部结束。复杂度同上。</p><h1 id="141-Linked-List-Cycle"><a href="#141-Linked-List-Cycle" class="headerlink" title="141. Linked List Cycle"></a>141. Linked List Cycle</h1><p>双指针。时间$O(n)$，空间$O(1)$。注意快慢指针的初始化，两个都初始化成head了，然后<code>while(slow!=fast)</code>进不去。。。</p><h1 id="142-Linked-List-Cycle-II-🌟"><a href="#142-Linked-List-Cycle-II-🌟" class="headerlink" title="142. Linked List Cycle II 🌟"></a>142. Linked List Cycle II 🌟</h1><p>指针相遇后让一个指针回<code>head</code>，然后两个指针都一步一步走直到相遇。</p><h1 id="146-LRU-Cache-🌟"><a href="#146-LRU-Cache-🌟" class="headerlink" title="146. LRU Cache 🌟"></a>146. LRU Cache 🌟</h1><p>双向链表+哈希表。插入和查询都能$O(1)$。</p><h1 id="148-Sort-List-🌟"><a href="#148-Sort-List-🌟" class="headerlink" title="148. Sort List 🌟"></a>148. Sort List 🌟</h1><p>解析：<a href="https://leetcode-cn.com/problems/sort-list/solution/148-pai-xu-lian-biao-bottom-to-up-o1-kong-jian-by-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-list/solution/148-pai-xu-lian-biao-bottom-to-up-o1-kong-jian-by-/</a><br>使用自底向上的方法归并。使用cut和merge两个基本操作。链表题真是一不小心就会炸。。</p><h1 id="152-Maximum-Product-Subarray-🌟"><a href="#152-Maximum-Product-Subarray-🌟" class="headerlink" title="152. Maximum Product Subarray 🌟"></a>152. Maximum Product Subarray 🌟</h1><p>因为可能存在乘积为负的情况，所以同时记录当前最大最小值，在<code>nums[i] &lt; 0</code>时交换最大最小值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ret = INT_MIN, imax = <span class="number">1</span>, imin = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span>) swap(imax, imin);</span><br><span class="line">    imax = <span class="built_in">max</span>(imax*nums[i], nums[i]);</span><br><span class="line">    imin = <span class="built_in">min</span>(imin*nums[i], nums[i]);</span><br><span class="line">    ret = <span class="built_in">max</span>(ret, imax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="155-Min-Stack"><a href="#155-Min-Stack" class="headerlink" title="155. Min Stack"></a>155. Min Stack</h1><p>两个辅助栈，<code>stackValue</code>和<code>stackMin</code>。push时，当加入的数字小于或等于<code>stackMin.top()</code>才加入<code>stackMin</code>。</p><h1 id="160-Intersection-of-Two-Linked-Lists"><a href="#160-Intersection-of-Two-Linked-Lists" class="headerlink" title="160. Intersection of Two Linked Lists"></a>160. Intersection of Two Linked Lists</h1><p>双指针。先测两个链表长度，然后看最后是否到达同一个节点。然后两个指针回到链表头，链表较长的指针先走相差的步数，然后两个指针一起走，直到相遇在交点。</p><h1 id="169-Majority-Element"><a href="#169-Majority-Element" class="headerlink" title="169. Majority Element"></a>169. Majority Element</h1><p>题目保证了一定Majority Element出现。<br>方法一：哈希表。时间$O(n)$，空间$O(n)$。<br>方法二：排序，然后取中位数。时间$O(n\log n)$，空间$O(1)$。</p><h1 id="198-House-Robber"><a href="#198-House-Robber" class="headerlink" title="198. House Robber"></a>198. House Robber</h1><p>DP。<code>dp[i] = max(dp[i-2] + nums[i], dp[i-3]+nums[i])</code>。</p><h1 id="200-Number-of-Islands"><a href="#200-Number-of-Islands" class="headerlink" title="200. Number of Islands"></a>200. Number of Islands</h1><p>DFS。</p><h1 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a>206. Reverse Linked List</h1><p>递归：时间$O(n)$，空间$O(n)$。<br>迭代：时间$O(n)$，空间$O(1)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode *prev = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = prev;</span><br><span class="line">        prev = cur, cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="207-Course-Schedule"><a href="#207-Course-Schedule" class="headerlink" title="207. Course Schedule"></a>207. Course Schedule</h1><p>拓扑排序，BFS。时间$O(m+n)$。</p><h1 id="208-Implement-Trie-Prefix-Tree"><a href="#208-Implement-Trie-Prefix-Tree" class="headerlink" title="208. Implement Trie (Prefix Tree)"></a>208. Implement Trie (Prefix Tree)</h1><h1 id="215-Kth-Largest-Element-in-an-Array"><a href="#215-Kth-Largest-Element-in-an-Array" class="headerlink" title="215. Kth Largest Element in an Array"></a>215. Kth Largest Element in an Array</h1><p>方法一：堆。时间$O(n\log k)$，空间$O(k)$。<br>方法二：快排。时间平均$O(n)$，最坏$O(n^2)$，空间$O(n)$。</p><h1 id="221-Maximal-Square-🌟"><a href="#221-Maximal-Square-🌟" class="headerlink" title="221. Maximal Square 🌟"></a>221. Maximal Square 🌟</h1><p>方法一：DP。<code>if(matrix[i][j] == &#39;1&#39;) dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1</code>。时间$O(nm))$，空间可以压缩到$O(m)$。<br>方法二：栈。类似84，84。复杂度同上。</p><h1 id="226-Invert-Binary-Tree"><a href="#226-Invert-Binary-Tree" class="headerlink" title="226. Invert Binary Tree"></a>226. Invert Binary Tree</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode* left = invertTree(root-&gt;left);</span><br><span class="line">    TreeNode* right = invertTree(root-&gt;right);</span><br><span class="line">    root-&gt;left = right;</span><br><span class="line">    root-&gt;right = left;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="234-Palindrome-Linked-List"><a href="#234-Palindrome-Linked-List" class="headerlink" title="234. Palindrome Linked List"></a>234. Palindrome Linked List</h1><p>方法一：复制到一个数组里再判断。时间$O(n)$，空间$O(n)$。<br>方法二：从中间切开，把后一半反转（见206），再逐一比较。时间$O(n)$，空间$O(1)$。</p><h1 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree-🌟"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree-🌟" class="headerlink" title="236. Lowest Common Ancestor of a Binary Tree 🌟"></a>236. Lowest Common Ancestor of a Binary Tree 🌟</h1><p>递归，DFS。时间$O(n)$，空间$O(n)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) <span class="keyword">return</span> root;</span><br><span class="line">    TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">    TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">    <span class="keyword">if</span> (left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (left) <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (right) <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="238-Product-of-Array-Except-Self-🌟"><a href="#238-Product-of-Array-Except-Self-🌟" class="headerlink" title="238. Product of Array Except Self 🌟"></a>238. Product of Array Except Self 🌟</h1><p>左右累乘。时间$O(n)$，空间$O(1)$（如果不算返回的数组）。</p><h1 id="239-Sliding-Window-Maximum-🌟"><a href="#239-Sliding-Window-Maximum-🌟" class="headerlink" title="239. Sliding Window Maximum 🌟"></a>239. Sliding Window Maximum 🌟</h1><p>双端队列。时间$O(n)$。deque种元素递减。更新时，先检查合法性，再检查单调性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty() &amp;&amp; i - q.front() &gt;= k)</span><br><span class="line">        q.pop_front();</span><br><span class="line">    <span class="keyword">while</span> (!q.empty() &amp;&amp; nums[i] &gt;= nums[q.back()])</span><br><span class="line">        q.pop_back();</span><br><span class="line">    q.push_back(i);</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= k<span class="number">-1</span>) ret.push_back(nums[q.front()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用堆的话，在大小为k的堆里插入元素时间为$O(\log k)$，所以总时间为$O(n\log k)$。</p><h1 id="240-Search-a-2D-Matrix-II-🌟"><a href="#240-Search-a-2D-Matrix-II-🌟" class="headerlink" title="240. Search a 2D Matrix II 🌟"></a>240. Search a 2D Matrix II 🌟</h1><p>从右上角开始往左往右移动。时间$O(m+n)$。</p><h1 id="279-Perfect-Squares-🌟"><a href="#279-Perfect-Squares-🌟" class="headerlink" title="279. Perfect Squares 🌟"></a>279. Perfect Squares 🌟</h1><p>BFS/DP。时间$O(n\sqrt{n})$</p><h1 id="283-Move-Zeroes-🌟"><a href="#283-Move-Zeroes-🌟" class="headerlink" title="283. Move Zeroes 🌟"></a>283. Move Zeroes 🌟</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++)</span><br><span class="line">    <span class="keyword">if</span>(nums[j] != <span class="number">0</span>) nums[i++] = nums[j];</span><br><span class="line"><span class="keyword">for</span>(; i &lt; nums.<span class="built_in">size</span>(); i++) nums[i] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h1 id="287-Find-the-Duplicate-Number-🌟"><a href="#287-Find-the-Duplicate-Number-🌟" class="headerlink" title="287. Find the Duplicate Number 🌟"></a>287. Find the Duplicate Number 🌟</h1><p>转换成142处理。<code>i</code>表示<code>Node*</code>，指向的节点的<code>val</code>和<code>next</code>都是<code>nums[i]</code>。</p><h1 id="297-Serialize-and-Deserialize-Binary-Tree-🌟"><a href="#297-Serialize-and-Deserialize-Binary-Tree-🌟" class="headerlink" title="297. Serialize and Deserialize Binary Tree 🌟"></a>297. Serialize and Deserialize Binary Tree 🌟</h1><p>可以DFS（先序遍历）和BFS（层次遍历）。注意stringstream的用法。在遇到NULL时，在字符串中加#。<br>题解：<a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/solution/liang-chong-jie-fa-by-jason-2-13/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/solution/liang-chong-jie-fa-by-jason-2-13/</a></p><h1 id="300-Longest-Increasing-Subsequence-🌟"><a href="#300-Longest-Increasing-Subsequence-🌟" class="headerlink" title="300. Longest Increasing Subsequence 🌟"></a>300. Longest Increasing Subsequence 🌟</h1><p>传统DP，时间$O(n^2)$。能够优化到到$O(n\log n)$。使用一个数组来记录长度为$i$的上升子序列最后一位数最小能到多少。<br><a href="https://www.acwing.com/solution/LeetCode/content/287/" target="_blank" rel="noopener">https://www.acwing.com/solution/LeetCode/content/287/</a></p><h1 id="301-Remove-Invalid-Parentheses"><a href="#301-Remove-Invalid-Parentheses" class="headerlink" title="301. Remove Invalid Parentheses"></a>301. Remove Invalid Parentheses</h1><p>回溯。先确定要删除多少左右括号，再进行回溯，注意合法性剪枝。时间$O(2^n)$。<br>确定删除多少左右括号的代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : s)&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'('</span>)</span><br><span class="line">        leftRemove++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (leftRemove == <span class="number">0</span>) rightRemove++;</span><br><span class="line">        <span class="keyword">else</span> leftRemove--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="309. Best Time to Buy and Sell Stock with Cooldown"></a>309. Best Time to Buy and Sell Stock with Cooldown</h1><p>DP，<code>hold</code>和<code>unhold</code>分别表示当天持有还是不持有股票。时间$O(n)$，空间$O(n)$，可以进一步压缩到$O(1)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hold[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">    unhold[i] = <span class="built_in">max</span>(hold[i<span class="number">-1</span>] + prices[i], unhold[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">        hold[i] = <span class="built_in">max</span>(hold[i<span class="number">-1</span>], - prices[i]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        hold[i] = <span class="built_in">max</span>(hold[i<span class="number">-1</span>], unhold[i<span class="number">-2</span>] - prices[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> unhold[n<span class="number">-1</span>];</span><br></pre></td></tr></table></figure><p>一个团灭所有的股票买卖问题的帖子：<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems</a></p><h1 id="312-Burst-Balloons-🌟"><a href="#312-Burst-Balloons-🌟" class="headerlink" title="312. Burst Balloons 🌟"></a>312. Burst Balloons 🌟</h1><p>解析：<a href="https://www.acwing.com/solution/LeetCode/content/297/" target="_blank" rel="noopener">https://www.acwing.com/solution/LeetCode/content/297/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= n; len++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - len + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = i + len <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= j; k++)</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i][k<span class="number">-1</span>] + nums[i<span class="number">-1</span>]*nums[k]*nums[j+<span class="number">1</span>] + dp[k+<span class="number">1</span>][j]);                </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="322-Coin-Change"><a href="#322-Coin-Change" class="headerlink" title="322. Coin Change"></a>322. Coin Change</h1><p>DP。时间$O(mn)$。</p><h1 id="337-House-Robber-III-🌟"><a href="#337-House-Robber-III-🌟" class="headerlink" title="337. House Robber III 🌟"></a>337. House Robber III 🌟</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dfs(TreeNode* root)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left = dfs(root-&gt;left);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right = dfs(root-&gt;right);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    ret[<span class="number">0</span>] = <span class="built_in">max</span>(left[<span class="number">0</span>], left[<span class="number">1</span>]) + <span class="built_in">max</span>(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line">    ret[<span class="number">1</span>] = root-&gt;val + left[<span class="number">0</span>] + right[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="338-Counting-Bits"><a href="#338-Counting-Bits" class="headerlink" title="338. Counting Bits"></a>338. Counting Bits</h1><p>偶数的popcount等于它除以二结果的popcount，奇数的popcount等于比它小1的偶数的popcount加一。</p><h1 id="347-Top-K-Frequent-Elements"><a href="#347-Top-K-Frequent-Elements" class="headerlink" title="347. Top K Frequent Elements"></a>347. Top K Frequent Elements</h1><p>用哈希表维护元素出现频率，用优先队列选出最大的几个。时间$O(n + k\log n)$</p><h1 id="394-Decode-String-🌟"><a href="#394-Decode-String-🌟" class="headerlink" title="394. Decode String 🌟"></a>394. Decode String 🌟</h1><p>栈。时间空间都是$O(n)$。<br><a href="https://leetcode-cn.com/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/</a></p><h1 id="399-Evaluate-Division"><a href="#399-Evaluate-Division" class="headerlink" title="399. Evaluate Division"></a>399. Evaluate Division</h1><p>将除数被除数当作节点，进行BFS。</p><h1 id="406-Queue-Reconstruction-by-Height-🌟"><a href="#406-Queue-Reconstruction-by-Height-🌟" class="headerlink" title="406. Queue Reconstruction by Height 🌟"></a>406. Queue Reconstruction by Height 🌟</h1><p>先按$h$从高到低排，内部再按$k$从小到大排，再逐个插入新建的返回队列中。时间$O(n^2$。</p><h1 id="416-Partition-Equal-Subset-Sum"><a href="#416-Partition-Equal-Subset-Sum" class="headerlink" title="416. Partition Equal Subset Sum"></a>416. Partition Equal Subset Sum</h1><p>转换成01背包，数组里存的是bool。</p><h1 id="437-Path-Sum-III-🌟"><a href="#437-Path-Sum-III-🌟" class="headerlink" title="437. Path Sum III 🌟"></a>437. Path Sum III 🌟</h1><p>DFS。注意存下根节点到路径上距离为一定值的点个数。每次到一个点，检查路径上与它相差<code>sum</code>的点的个数。时间空间都是$O(n)$。</p><h1 id="438-Find-All-Anagrams-in-a-String-🌟"><a href="#438-Find-All-Anagrams-in-a-String-🌟" class="headerlink" title="438. Find All Anagrams in a String 🌟"></a>438. Find All Anagrams in a String 🌟</h1><p>滑动窗口，类似方法可以做3和76。时间$O(n)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, c = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(need.<span class="built_in">find</span>(s[i]) != need.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        window[s[i]]++;</span><br><span class="line">        <span class="keyword">if</span> (window[s[i]] == need[s[i]]) c++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c == need.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span> (i - j + <span class="number">1</span> == p.<span class="built_in">size</span>()) ret.push_back(j);</span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">find</span>(s[j]) != need.<span class="built_in">end</span>())&#123;</span><br><span class="line">            window[s[j]]--;</span><br><span class="line">            <span class="keyword">if</span> (window[s[j]] &lt; need[s[j]]) c--;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="448-Find-All-Numbers-Disappeared-in-an-Array"><a href="#448-Find-All-Numbers-Disappeared-in-an-Array" class="headerlink" title="448. Find All Numbers Disappeared in an Array"></a>448. Find All Numbers Disappeared in an Array</h1><p>数组内调换，将对应数放到对应的位置上，类似41。时间$O(n)$，空间$O(1)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span> (nums[nums[i]<span class="number">-1</span>] != nums[i])&#123;</span><br><span class="line">        swap(nums[i], nums[nums[i]<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>)</span><br><span class="line">        ret.push_back(i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="461-Hamming-Distance"><a href="#461-Hamming-Distance" class="headerlink" title="461. Hamming Distance"></a>461. Hamming Distance</h1><h1 id="494-Target-Sum-🌟"><a href="#494-Target-Sum-🌟" class="headerlink" title="494. Target Sum 🌟"></a>494. Target Sum 🌟</h1><p>类似416，转换成01背包。时间$O(n * {sum})$，空间$O(sum)$。</p><h1 id="538-Convert-BST-to-Greater-Tree"><a href="#538-Convert-BST-to-Greater-Tree" class="headerlink" title="538. Convert BST to Greater Tree"></a>538. Convert BST to Greater Tree</h1><p>累加递归。时间$O(n)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    convertBST(root-&gt;right);</span><br><span class="line">    root-&gt;val += sum;</span><br><span class="line">    sum = root-&gt;val;</span><br><span class="line">    convertBST(root-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="543-Diameter-of-Binary-Tree-🌟"><a href="#543-Diameter-of-Binary-Tree-🌟" class="headerlink" title="543. Diameter of Binary Tree 🌟"></a>543. Diameter of Binary Tree 🌟</h1><p>在求树的深度时，同时求直径。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maxPath = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> maxPath;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = dfs(root-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> right = dfs(root-&gt;right);</span><br><span class="line">    maxPath = <span class="built_in">max</span>(maxPath, left + right + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="560-Subarray-Sum-Equals-K-🌟"><a href="#560-Subarray-Sum-Equals-K-🌟" class="headerlink" title="560. Subarray Sum Equals K 🌟"></a>560. Subarray Sum Equals K 🌟</h1><p>累加+哈希。时间空间都是$O(n)$。</p><h1 id="581-Shortest-Unsorted-Continuous-Subarray"><a href="#581-Shortest-Unsorted-Continuous-Subarray" class="headerlink" title="581. Shortest Unsorted Continuous Subarray"></a>581. Shortest Unsorted Continuous Subarray</h1><p>寻找数组中间降序的最低的元素，然后把用这个极值确定左边排好了的范围。右边同理。时间$O(n)$，空间$O(1)$。</p><h1 id="617-Merge-Two-Binary-Trees"><a href="#617-Merge-Two-Binary-Trees" class="headerlink" title="617. Merge Two Binary Trees"></a>617. Merge Two Binary Trees</h1><h1 id="621-Task-Scheduler-🌟"><a href="#621-Task-Scheduler-🌟" class="headerlink" title="621. Task Scheduler 🌟"></a>621. Task Scheduler 🌟</h1><p>直接设计。。。<a href="https://leetcode-cn.com/problems/task-scheduler/solution/ren-wu-diao-du-qi-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/task-scheduler/solution/ren-wu-diao-du-qi-by-leetcode/</a></p><h1 id="647-Palindromic-Substrings"><a href="#647-Palindromic-Substrings" class="headerlink" title="647. Palindromic Substrings"></a>647. Palindromic Substrings</h1><p>中心扩展。时间$O(n^2)$，空间$O(1)$。</p><h1 id="739-Daily-Temperatures"><a href="#739-Daily-Temperatures" class="headerlink" title="739. Daily Temperatures"></a>739. Daily Temperatures</h1><p>栈。时间$O(n)$，空间$O(n)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(!st.empty() &amp;&amp; T[i] &gt; T[st.top()])&#123;</span><br><span class="line">        <span class="keyword">int</span> top = st.top();</span><br><span class="line">        st.pop();</span><br><span class="line">        res[top] = i - top;</span><br><span class="line">    &#125;</span><br><span class="line">    st.push(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始刷Top 100 Liked Questions啦！（后50题）&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://luciusssss.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://luciusssss.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="http://luciusssss.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记 1</title>
    <link href="http://luciusssss.github.io/2020/01/20/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-1/"/>
    <id>http://luciusssss.github.io/2020/01/20/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-1/</id>
    <published>2020-01-20T04:45:55.000Z</published>
    <updated>2020-01-28T12:10:45.283Z</updated>
    
    <content type="html"><![CDATA[<p>开始刷Top 100 Liked Questions啦！（前50题）</p><a id="more"></a><p>先列一些中文题解的网站：</p><ul><li><a href="https://www.acwing.com/solution/leetcode/" target="_blank" rel="noopener">https://www.acwing.com/solution/leetcode/</a></li><li><a href="https://leetcode.wang/" target="_blank" rel="noopener">https://leetcode.wang/</a></li></ul><h1 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h1><p>用unordered_map。O(n)</p><h1 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2. Add Two Numbers"></a>2. Add Two Numbers</h1><p>同时遍历两个链表</p><h1 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3. Longest Substring Without Repeating Characters"></a>3. Longest Substring Without Repeating Characters</h1><p>方法一：DP。计算以第i位字符位结尾的满足要求的字符串长度。$O(n^2)$。注意edge case: 长度为0字符串，长度为1字符串之类的。。。<br>方法二：滑动窗口，$O(n)$。<a href="https://leetcode.com/articles/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">https://leetcode.com/articles/longest-substring-without-repeating-characters/</a></p><h1 id="4-Median-of-Two-Sorted-Arrays-🌟"><a href="#4-Median-of-Two-Sorted-Arrays-🌟" class="headerlink" title="4. Median of Two Sorted Arrays 🌟"></a>4. Median of Two Sorted Arrays 🌟</h1><p>第一道hard题，解析见<a href="https://leetcode.com/articles/median-of-two-sorted-arrays/" target="_blank" rel="noopener">https://leetcode.com/articles/median-of-two-sorted-arrays/</a><br>复杂度为$O(\log min(m, n))$.</p><h1 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5. Longest Palindromic Substring"></a>5. Longest Palindromic Substring</h1><p>一开始想了一个O(n)的DP后来发现是错的，比如在“bananas”这个例子上。。。<br>中心扩展，分奇偶长度串。写扩展函数时，注意把string串引用比较好。时间$O(n^2)$，空间$O(n)$。<br>DP，时间$O(n^2)$，空间$O(n^2)$。<br>$O(n)$的算法，Manacher，类似KMP？之后再看。</p><h1 id="10-Regular-Expression-Matching-🌟"><a href="#10-Regular-Expression-Matching-🌟" class="headerlink" title="10. Regular Expression Matching 🌟"></a>10. Regular Expression Matching 🌟</h1><p>需要想一下的DP，O(mn)。<br>解析<a href="https://www.cnblogs.com/Jessey-Ge/p/10993447.html" target="_blank" rel="noopener">https://www.cnblogs.com/Jessey-Ge/p/10993447.html</a></p><h1 id="11-Container-With-Most-Water-🌟"><a href="#11-Container-With-Most-Water-🌟" class="headerlink" title="11. Container With Most Water 🌟"></a>11. Container With Most Water 🌟</h1><p>O(n)的方法：双指针，每次将较短的那个向内移动。</p><h1 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15. 3Sum"></a>15. 3Sum</h1><p>类似Two Sum。先排序$O(n\log n)$。固定target，然后双指针找Two Sum。总共$O(n^2)$。<br><strong>尤其注意两层循环都要把重复的去除。</strong></p><h1 id="17-Letter-Combinations-of-a-Phone-Number"><a href="#17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="17. Letter Combinations of a Phone Number"></a>17. Letter Combinations of a Phone Number</h1><p>直接枚举。vector删除第一个元素可以用<code>ret.erase(ret.begin())</code>。<strong>尤其注意边界情况！！！当输入字符串为空要单独判断！！！</strong></p><h1 id="19-Remove-Nth-Node-From-End-of-List"><a href="#19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="19. Remove Nth Node From End of List"></a>19. Remove Nth Node From End of List</h1><p>可以用双指针走一遍。 可以使用dummy指针当作链表头。</p><h1 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20. Valid Parentheses"></a>20. Valid Parentheses</h1><p>stack。但我还是没有一次bug-free。。。取stack的top的时，一定要先检查是否为空！！！</p><h1 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21. Merge Two Sorted Lists"></a>21. Merge Two Sorted Lists</h1><h1 id="22-Generate-Parentheses"><a href="#22-Generate-Parentheses" class="headerlink" title="22. Generate Parentheses"></a>22. Generate Parentheses</h1><p>回溯。一开始用了stack，其实不用。<code>leftCnt &lt; n</code>时尝试加上<code>(</code>，<code>rightCnt &lt; leftCnt</code>时尝试加上<code>)</code>。</p><h1 id="23-Merge-k-Sorted-Lists"><a href="#23-Merge-k-Sorted-Lists" class="headerlink" title="23. Merge k Sorted Lists"></a>23. Merge k Sorted Lists</h1><p>分治。时间$O(N\log k)$。注意<code>k==0</code>的情形。空间$O(1)$，两两合并可以参照<a href="https://www.geeksforgeeks.org/merge-k-sorted-linked-lists/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/merge-k-sorted-linked-lists/</a><br>优先队列，时间复杂度一样：<a href="https://blog.csdn.net/Ethan95/article/details/85195403" target="_blank" rel="noopener">https://blog.csdn.net/Ethan95/article/details/85195403</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优先队列的使用：默认是从大到小排。自定义时需要重载&lt;符号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node a, Node b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.x == b.x)<span class="keyword">return</span> a.y&gt;b.y;</span><br><span class="line">        <span class="keyword">return</span> a.x&gt;b.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;Node, <span class="built_in">vector</span>&lt;Node&gt;, cmp&gt;p;</span><br></pre></td></tr></table></figure><h1 id="31-Next-Permutation-🌟"><a href="#31-Next-Permutation-🌟" class="headerlink" title="31. Next Permutation 🌟"></a>31. Next Permutation 🌟</h1><p>有非常巧妙的时间$O(n)$，空间$O(1)$的做法：<a href="https://leetcode.com/articles/next-permutation/" target="_blank" rel="noopener">https://leetcode.com/articles/next-permutation/</a><br>首先从结尾开始找到最长的不升子序列，然后将该序列前一位数换成子序列中刚好比它大一点的数，在将子序列reverse一下。</p><h1 id="32-Longest-Valid-Parentheses-🌟"><a href="#32-Longest-Valid-Parentheses-🌟" class="headerlink" title="32. Longest Valid Parentheses 🌟"></a>32. Longest Valid Parentheses 🌟</h1><p>一道hard的DP。时间空间都是$O(n)$。解析：<a href="https://leetcode.com/articles/longest-valid-parentheses/" target="_blank" rel="noopener">https://leetcode.com/articles/longest-valid-parentheses/</a>  若当前为<code>)</code>则可能存在以当前位为结尾的有效串，分<code>))</code>和<code>()</code>讨论。<br>也可以用栈，复杂度相同。更清晰的解释：<a href="https://leetcode.wang/leetCode-32-Longest-Valid-Parentheses.html" target="_blank" rel="noopener">https://leetcode.wang/leetCode-32-Longest-Valid-Parentheses.html</a><br>时间$O(n)$的方法，可以从22题Generate Parentheses找到影子。<strong>注意要从左到右、从右到左各扫描一遍。</strong></p><h1 id="33-Search-in-Rotated-Sorted-Array-🌟"><a href="#33-Search-in-Rotated-Sorted-Array-🌟" class="headerlink" title="33. Search in Rotated Sorted Array 🌟"></a>33. Search in Rotated Sorted Array 🌟</h1><p>二分。<a href="https://www.cnblogs.com/zle1992/p/8996225.html" target="_blank" rel="noopener">https://www.cnblogs.com/zle1992/p/8996225.html</a><br>分别在左边有序和右边有序的情况下判断目标值的位置。</p><h1 id="34-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><a href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array" class="headerlink" title="34. Find First and Last Position of Element in Sorted Array"></a>34. Find First and Last Position of Element in Sorted Array</h1><p>二分。最直观的方法可以三次二分。</p><h1 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a>39. Combination Sum</h1><p>回溯。一开始我的想法是穷举每个数字可以使用的次数，但跑下来很慢。<br>后来看了一种回溯方式是，每次调函数加数字，都从已经使用过的最大的数字开始试着加，这种方法快很多。</p><h1 id="41-First-Missing-Positive-🌟"><a href="#41-First-Missing-Positive-🌟" class="headerlink" title="41. First Missing Positive 🌟"></a>41. First Missing Positive 🌟</h1><p>很tricky。。。<a href="https://www.cnblogs.com/grandyang/p/4395963.html" target="_blank" rel="noopener">https://www.cnblogs.com/grandyang/p/4395963.html</a></p><h1 id="42-Trapping-Rain-Water-🌟"><a href="#42-Trapping-Rain-Water-🌟" class="headerlink" title="42. Trapping Rain Water 🌟"></a>42. Trapping Rain Water 🌟</h1><p>DP分别计算对于每个i，左右最高的墙壁。然后在遍历一遍i，每次加上最矮墙壁高减去底高。</p><h1 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46. Permutations"></a>46. Permutations</h1><h1 id="48-Rotate-Image"><a href="#48-Rotate-Image" class="headerlink" title="48. Rotate Image"></a>48. Rotate Image</h1><p>方法一：每次四个数旋转<br>方法二：先转置，再左右翻折</p><h1 id="49-Group-Anagrams"><a href="#49-Group-Anagrams" class="headerlink" title="49. Group Anagrams"></a>49. Group Anagrams</h1><p>方法一：先对每个字符串排序，再以排序后的串为key扔进map里，$O(nk\log k)$。<br>方法二：对于每个字符串，统计每个字母出现的次数，并成一个key，$O(nk)$。<br>使用map的iterator时，注意<code>it != m.end()</code>中用不等号。</p><h1 id="53-Maximum-Subarray-🌟"><a href="#53-Maximum-Subarray-🌟" class="headerlink" title="53. Maximum Subarray 🌟"></a>53. Maximum Subarray 🌟</h1><p>DP可以时间O(n)，空间O(1).<code>dp = max(dp + nums[i], nums[i])</code><br>二分，如果要找的数组不包含 mid，然后得到左边和右边最大的值，如果要找的数组包含mid则左右扩展。$O(O\log n)$</p><h1 id="55-Jump-Game-🌟"><a href="#55-Jump-Game-🌟" class="headerlink" title="55. Jump Game 🌟"></a>55. Jump Game 🌟</h1><p>贪心，O(n)，可以转换成区间覆盖。<br><a href="https://www.acwing.com/solution/LeetCode/content/7762/" target="_blank" rel="noopener">https://www.acwing.com/solution/LeetCode/content/7762/</a></p><h1 id="56-Merge-Intervals"><a href="#56-Merge-Intervals" class="headerlink" title="56. Merge Intervals"></a>56. Merge Intervals</h1><p>区间合并。先排序，再遍历。$O(n\log n)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (ret.empty() || ret[cnt - <span class="number">1</span>][<span class="number">1</span>] &lt; intervals[i][<span class="number">0</span>])&#123;</span><br><span class="line">        ret.push_back(intervals[i]);</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret[cnt<span class="number">-1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(ret[cnt<span class="number">-1</span>][<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sort自定义排序<code>static bool cmp(const vector&lt;int&gt;&amp; a,const vector&lt;int&gt;&amp; b)</code></p><h1 id="62-Unique-Paths"><a href="#62-Unique-Paths" class="headerlink" title="62. Unique Paths"></a>62. Unique Paths</h1><p>方法一：组合数学，注意用long long，分子是从$\max(m, n)$到$m+n-2$，分母是$1$到$\min(m, n)-1$。<br>方法二：DP，时间$O(mn)$, 空间可以压到$O(\min (m,n))$。</p><h1 id="64-Minimum-Path-Sum"><a href="#64-Minimum-Path-Sum" class="headerlink" title="64. Minimum Path Sum"></a>64. Minimum Path Sum</h1><p>类似62，DP，时间$O(mn)$, 空间$O(\min (m,n))$。</p><h1 id="70-Climbing-Stairs"><a href="#70-Climbing-Stairs" class="headerlink" title="70. Climbing Stairs"></a>70. Climbing Stairs</h1><h1 id="72-Edit-Distance"><a href="#72-Edit-Distance" class="headerlink" title="72. Edit Distance"></a>72. Edit Distance</h1><p>经典DP，也没一次bug-free，把<code>word1[i-1] == word2[j-1]</code>写成了<code>word1[i] == word2[j]</code>。。。要小心。。。</p><h1 id="75-Sort-Colors"><a href="#75-Sort-Colors" class="headerlink" title="75. Sort Colors"></a>75. Sort Colors</h1><p>两种方法时间$O(n)$，空间$O(1)$。<br>方法一：两次遍历，第一次遍历统计0，1，2分别有多少个。<br>方法二：双指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= r; )&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] == <span class="number">2</span>)</span><br><span class="line">        swap(nums[i], nums[r--]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)</span><br><span class="line">        swap(nums[i++], nums[l++]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="76-Minimum-Window-Substring-🌟"><a href="#76-Minimum-Window-Substring-🌟" class="headerlink" title="76. Minimum Window Substring 🌟"></a>76. Minimum Window Substring 🌟</h1><p>滑动窗口，$O(n)$。首先用哈希表统计出T中所有字符出现的次数，再用两个指针更新答案，具体见<a href="https://www.acwing.com/solution/LeetCode/content/160/" target="_blank" rel="noopener">https://www.acwing.com/solution/LeetCode/content/160/</a></p><h1 id="78-Subsets"><a href="#78-Subsets" class="headerlink" title="78. Subsets"></a>78. Subsets</h1><h1 id="79-Word-Search"><a href="#79-Word-Search" class="headerlink" title="79. Word Search"></a>79. Word Search</h1><p>DFS，$O(n^2k^3)$。为了防止走回头路，可以暂时将当前的格子设为一个特殊字符，这样不需要额外的空间记录是否走过。</p><h1 id="84-Largest-Rectangle-in-Histogram-🌟"><a href="#84-Largest-Rectangle-in-Histogram-🌟" class="headerlink" title="84. Largest Rectangle in Histogram 🌟"></a>84. Largest Rectangle in Histogram 🌟</h1><p>类似42，用栈解决，栈里的柱子单调不减。对于当前柱子，找到左右第一个比它小的柱子，然后计算面积。在heights最后加一个-1可以把栈清空$O(n)$。<a href="https://www.acwing.com/solution/LeetCode/content/140/" target="_blank" rel="noopener">https://www.acwing.com/solution/LeetCode/content/140/</a></p><h1 id="85-Maximal-Rectangle-🌟"><a href="#85-Maximal-Rectangle-🌟" class="headerlink" title="85. Maximal Rectangle 🌟"></a>85. Maximal Rectangle 🌟</h1><p>基于84做，一行一行来，把1当作柱子。$O(mn)$。</p><h1 id="94-Binary-Tree-Inorder-Traversal"><a href="#94-Binary-Tree-Inorder-Traversal" class="headerlink" title="94. Binary Tree Inorder Traversal"></a>94. Binary Tree Inorder Traversal</h1><h1 id="96-Unique-Binary-Search-Trees"><a href="#96-Unique-Binary-Search-Trees" class="headerlink" title="96. Unique Binary Search Trees"></a>96. Unique Binary Search Trees</h1><p>DP，时间$O(n^2)$。卡塔兰数。</p><h1 id="98-Validate-Binary-Search-Tree"><a href="#98-Validate-Binary-Search-Tree" class="headerlink" title="98. Validate Binary Search Tree"></a>98. Validate Binary Search Tree</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root, TreeNode *leftMin=<span class="literal">NULL</span>,TreeNode *rightMax=<span class="literal">NULL</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(leftMin != <span class="literal">NULL</span> &amp;&amp; leftMin-&gt;val &gt;= root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(rightMax != <span class="literal">NULL</span> &amp;&amp; rightMax-&gt;val &lt;= root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root-&gt;left, leftMin, root) &amp;&amp; isValidBST(root-&gt;right, root, rightMax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a>101. Symmetric Tree</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* left, TreeNode* right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="literal">NULL</span> || right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> left-&gt;val == right-&gt;val &amp;&amp; dfs(left-&gt;left, right-&gt;right) &amp;&amp; dfs(left-&gt;right, right-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不递归用栈的：<a href="https://www.acwing.com/solution/LeetCode/content/182/" target="_blank" rel="noopener">https://www.acwing.com/solution/LeetCode/content/182/</a></p><h1 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. Binary Tree Level Order Traversal"></a>102. Binary Tree Level Order Traversal</h1><p>BFS。每层都新开一个level的队列。</p><h1 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a>104. Maximum Depth of Binary Tree</h1><h1 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-🌟"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-🌟" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal 🌟"></a>105. Construct Binary Tree from Preorder and Inorder Traversal 🌟</h1><p>可以用一个hash存inorder里每个数对应的序号，建hash table为$O(n)$，把查询的时间降到$O(1)$。总的复杂度为$O(n)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> preLeft, <span class="keyword">int</span> preRight, <span class="keyword">int</span> inLeft, <span class="keyword">int</span> inRight)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preLeft &gt; preRight) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> k = pos[preorder[preLeft]] - inLeft;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode(preorder[preLeft]);</span><br><span class="line">    root-&gt;left = dfs(preorder, inorder, preLeft+<span class="number">1</span>, preLeft+k, inLeft, inLeft+k<span class="number">-1</span>);</span><br><span class="line">    root-&gt;right = dfs(preorder, inorder, preLeft+k+<span class="number">1</span>, preRight, inLeft+k+<span class="number">1</span>, inRight);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="114-Flatten-Binary-Tree-to-Linked-List"><a href="#114-Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="114. Flatten Binary Tree to Linked List"></a>114. Flatten Binary Tree to Linked List</h1><p>时间$O(n)$，空间$O(1)$，要求原地。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    TreeNode* cur = root;</span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left)&#123;</span><br><span class="line">            TreeNode* p = cur-&gt;left;</span><br><span class="line">            <span class="keyword">while</span>(p-&gt;right) p = p-&gt;right;</span><br><span class="line">            p-&gt;right = cur-&gt;right;</span><br><span class="line">            cur-&gt;right = cur-&gt;left;</span><br><span class="line">            cur-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. Best Time to Buy and Sell Stock"></a>121. Best Time to Buy and Sell Stock</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    minPrice = <span class="built_in">min</span>(minPrice, prices[i]);</span><br><span class="line">    ret = <span class="built_in">max</span>(ret, prices[i]-minPrice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="124-Binary-Tree-Maximum-Path-Sum-🌟"><a href="#124-Binary-Tree-Maximum-Path-Sum-🌟" class="headerlink" title="124. Binary Tree Maximum Path Sum 🌟"></a>124. Binary Tree Maximum Path Sum 🌟</h1><p>遍历每个点，把它记作割点，分别计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="built_in">max</span>(<span class="number">0</span>, dfs(root-&gt;left));</span><br><span class="line">    <span class="keyword">int</span> right = <span class="built_in">max</span>(<span class="number">0</span>, dfs(root-&gt;right));</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, left+right+root-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + root-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="128-Longest-Consecutive-Sequence-🌟"><a href="#128-Longest-Consecutive-Sequence-🌟" class="headerlink" title="128. Longest Consecutive Sequence 🌟"></a>128. Longest Consecutive Sequence 🌟</h1><p>要求时间O(n)。<br>方法一：并查集，注意先用unordered_set去重。<br>方法二：建一个<code>unordered_map&lt;int, bool&gt;</code>，对于<code>nums</code>里每个元素，如果比它小一的数不存在，则一次查找比它大的数。<br>方法三：<a href="https://www.acwing.com/solution/LeetCode/content/222/" target="_blank" rel="noopener">https://www.acwing.com/solution/LeetCode/content/222/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp; x : nums)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> left = tr_right[x - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> right = tr_left[x + <span class="number">1</span>];</span><br><span class="line">    tr_left[x - left] = <span class="built_in">max</span>(tr_left[x - left], left + <span class="number">1</span> + right);</span><br><span class="line">    tr_right[x + right] = <span class="built_in">max</span>(tr_right[x + right], left + <span class="number">1</span> + right);</span><br><span class="line">    res = <span class="built_in">max</span>(res, left + <span class="number">1</span> + right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="136-Single-Number"><a href="#136-Single-Number" class="headerlink" title="136. Single Number"></a>136. Single Number</h1><p>位运算异或。时间$O(n)$，无额外空间。</p><h1 id="138-Copy-List-with-Random-Pointer"><a href="#138-Copy-List-with-Random-Pointer" class="headerlink" title="138. Copy List with Random Pointer"></a>138. Copy List with Random Pointer</h1><p>hash table。时间$O(n)$。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始刷Top 100 Liked Questions啦！（前50题）&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://luciusssss.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://luciusssss.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="http://luciusssss.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2019，我读过的论文</title>
    <link href="http://luciusssss.github.io/2020/01/11/2019%EF%BC%8C%E6%88%91%E8%AF%BB%E8%BF%87%E7%9A%84%E8%AE%BA%E6%96%87/"/>
    <id>http://luciusssss.github.io/2020/01/11/2019%EF%BC%8C%E6%88%91%E8%AF%BB%E8%BF%87%E7%9A%84%E8%AE%BA%E6%96%87/</id>
    <published>2020-01-11T07:00:13.000Z</published>
    <updated>2020-01-21T10:40:44.674Z</updated>
    
    <content type="html"><![CDATA[<p>去年开始认真读论文还是从7月开始，主要读了很多Question Answering的论文，其中又以Machine Reading Comprehension为主，大概了解了QA这个领域在做些什么。<br>这里我把去年读过的论文简单列一下。其中我觉得值得一读的论文我会打上😻。<br>阅读过程中尤其感谢LAI Yuxuan师兄的指导！</p><h2 id="Survey"><a href="#Survey" class="headerlink" title="Survey"></a>Survey</h2><ul><li><p>NEURAL READING COMPREHENSION AND BEYOND 😻<br><em>Chen Danqi</em><br>陈丹琦的博士毕业论文，一篇对MRC比较全面且易懂的综述。</p></li><li><p>Neural Machine Reading Comprehension: Methods and Trends<br><em>Shanshan Liu, Xin Zhang, Sheng Zhang, Hui Wang, Weiming Zhang</em><br>国防科大的MRC综述，一些想法很大胆，但一些地方没有讲明白。</p></li><li><p>Recent Advances in Natural Language Inference: A Survey of Benchmarks, Resources, and Approaches 😻<br><em>Shane Storks, Qiaozi Gao, Joyce Y. Chai</em><br>对于（广义的）Commonsense QA做的综述。</p></li></ul><a id="more"></a><h2 id="Machine-Reading-Comprehension-Dataset"><a href="#Machine-Reading-Comprehension-Dataset" class="headerlink" title="Machine Reading Comprehension Dataset"></a>Machine Reading Comprehension Dataset</h2><ul><li><p>SQuAD: 100,000+ Questions for Machine Comprehension of Text 😻<br><em>Pranav Rajpurkar, Jian Zhang, Konstantin Lopyrev, Percy Liang</em>, EMNLP 16<br>MRC领域最经典的数据集SQuAD。这是不含unanswerable question的1.0版本，问题来源于wikipedia，人工根据文章提问题。</p></li><li><p>Know What You Don’t Know: Unanswerable Questions for SQuAD 😻<br><em>Pranav Rajpurkar, Robin Jia, Percy Liang</em>, ACL 18<br>SQuAD 2.0，加入了大量unanswerable question</p></li><li><p>NewsQA: A Machine Comprehension Dataset<br><em>Adam Trischler, Tong Wang, Xingdi Yuan, Justin Harris, Alessandro Sordoni, Philip Bachman, Kaheer Suleman</em><br>文章来源于CNN，提问者只能看到新闻的summary points，答案从来自新闻正文，从而避免问题和文章过于相似。</p></li><li><p>ReCoRD: Bridging the Gap between Human and Machine Commonsense Reading Comprehension<br><em>Sheng Zhang, Xiaodong Liu, Jingjing Liu, Jianfeng Gao, Kevin Duh, Benjamin Van Durme</em><br>一个cloze形式的阅读理解数据集。文章是新闻的前几段，从新闻的剩余部分挑一个句子，挖掉句子中一个实体当作问题。</p></li><li><p>Natural Questions: A Benchmark for Question Answering Research 😻<br><em>Google</em>, TACL 19<br>以整个维基页面为文章，文章较长，同时标注长答案和短答案。</p></li><li><p>BoolQ: Exploring the Surprising Difficulty of Natural Yes/No Questions<br><em>Christopher Clark, Kenton Lee, Ming-Wei Chang, Tom Kwiatkowski, Michael Collins, Kristina Toutanova</em>, NAACL 19<br>研究自然产生的yes/no questions，制作了阅读理解数据集BoolQ，发现从entailment data迁移学习在它上面表现较好。</p></li><li><p>QUOREF: A Reading Comprehension Dataset with Questions Requiring Coreferential Reasoning<br><em>Pradeep Dasigi, Nelson F. Liu, Ana Marasović, Noah A. Smith, Matt Gardner</em>, EMNLP 19<br>24k extractive MRC questions, 文章来自wiki(40%的文章是电影情节概要)，需要共指消解。</p></li><li><p>DuoRC: Towards complex language understanding with paraphrased reading comprehension<br><em>Amrita Saha, Rahul Aralikatte, Mitesh M. Khapra, Karthik Sankaranarayanan</em>, ACL 18<br>基于7680对电影情节概要(一篇来自维基，一篇来自imdb)。4 challenges: 很多问题与文章的lexical overlap低；需要background knowledge和commonsense knowledge；叙述性的文章经常需要综合多句的复杂推理；包含no answer的问题。</p></li><li><p>DuReader: a Chinese Machine Reading Comprehension Dataset from Real-world Applications<br><em>Baidu</em>, ACL18<br>中文MRC数据集。</p></li></ul><h2 id="Commonsense-QA-Dataset"><a href="#Commonsense-QA-Dataset" class="headerlink" title="Commonsense QA Dataset"></a>Commonsense QA Dataset</h2><ul><li><p>COMMONSENSEQA: A Question Answering Challenge Targeting Commonsense Knowledge 😻<br><em>Alon Talmor, Jonathan Herzig, Nicholas Lourie, Jonathan Berant</em>, NAACL 19<br>基于ConceptNet做的选择题形式的常识问答。</p></li><li><p>COSMOS QA: Machine Reading Comprehension with Contextual Commonsense Reasoning 😻<br><em>Lifu Huang, Ronan Le Bras, Chandra Bhagavatula, Yejin Choi</em>, EMNLP 19<br>阅读理解形式的选择题常识问答，需要通过commonsense inference来read between the lines。</p></li></ul><h2 id="Other-QA-Dataset"><a href="#Other-QA-Dataset" class="headerlink" title="Other QA Dataset"></a>Other QA Dataset</h2><ul><li><p>GeoSQA: A Benchmark for Scenario-based Question Answering in the Geography Domain at High School<br><em>Zixian Huang, Yulin Shen, Xiao Li, Yuang Wei, Gong Cheng, Lin Zhou, Xinyu Dai, Yuzhong Qu</em>, EMNLP 19<br>高考地理题。如何处理题目中的图？</p></li><li><p>MathQA: Towards Interpretable Math Word Problem Solving with Operation-Based Formalisms<br>37,200个数学题，附有选项和解题路径。</p></li></ul><h2 id="Dataset-Analysis-amp-Model-Analysis"><a href="#Dataset-Analysis-amp-Model-Analysis" class="headerlink" title="Dataset Analysis &amp; Model Analysis"></a>Dataset Analysis &amp; Model Analysis</h2><ul><li><p>What Makes Reading Comprehension Questions Easier?<br><em>Saku Sugawara, Kentaro Inui, Satoshi Sekine, Akiko Aizawa</em>, EMNLP 18<br>分析最近的12个MRC数据集，通过启发式规则分割数据集，然后检查各自的表现，认为<em>hard questions require knowledge inference and multiple-sentence reasoning</em>。</p></li><li><p>Adversarial Examples for Evaluating Reading Comprehension Systems 😻<br><em>Robin Jia, Percy Liang</em>, EMNLP 19<br>对MRC进行反思的比较早的一篇。通过在文章结尾加上对抗性的句子能让模型回答错问题。</p></li><li><p>Do NLP Models Know Numbers? Probing Numeracy in Embeddings 😻<br><em>Eric Wallace, Yizhong Wang, Sujian Li, Sameer Singh, Matt Gardner</em>, EMNLP 19<br>研究发现state-of-the-art的QA模型在DROP上也表现出很好的numerical reasoning能力。为了理解这种能力如何产生，作者探索了各种embedding方法在list maximum, number encoding, addition三个任务上的表现。发现standard embeddings中存在着很大程度的numeracy，character-level embeddings对numeracy的表示很精确。</p></li></ul><h2 id="QA-Model"><a href="#QA-Model" class="headerlink" title="QA Model"></a>QA Model</h2><ul><li><p>Bidirectional Attention Flow for Machine Comprehension 😻<br><em>Minjoon Seo, Aniruddha Kembhavi, Ali Farhadi, Hannaneh Hajishirzi</em>, ICLR 17<br>基于文章和问题双向注意力的BiDAF模型。是MRC中基于注意力机制最经典的模型。</p></li><li><p>Latent Retrieval for Weakly Supervised Open Domain Question Answering<br><em>Kenton Lee, Ming-Wei Chang, Kristina Toutanova</em>, ACL 19<br>提了一个Open Domain QA的端到端模型。</p><p><strong>下面是对于Conversational MRC的方法：</strong></p></li><li><p>GRAPHFLOW: Exploiting Conversation Flow with Graph Neural Networks for Conversational Machine Comprehension<br><em>Yu Chen, Lingfei Wu, Mohammed J. Zaki</em><br>做conversational MRC的，捕获对话中的conversational flow：将conversational flow建模成对话中的一系列latent states。</p></li><li><p>Answering Conversational Questions on Structured Data without Logical Forms<br><em>Thomas Müller, Francesco Piccinno, Massimo Nicosia, Peter Shaw, Yasemin Altun</em>, EMNLP 19<br>搜集了 包含6k个对于维基上的半结构化表格进行询问的问题序列 的数据集，并提出了一个无需logical froms的weakly supervised semantic parsing模型。</p></li><li><p>Technical report on Conversational Question Answering<br>在CoQA上使用RoBERTa + AT(Adversarial Training) + KD(Knowledge Distillation)，达到90.4 F1。</p><p><strong>下面是对于Multi-hop MRC的方法：</strong></p></li><li><p>Token-level Dynamic Self-Attention Network for Multi-Passage Reading Comprehension<br><em>Yimeng Zhuang, Huadong Wang</em>, ACL 19<br>在token-level处理cross-passage infomation，能够动态地从序列中选取重要的token，达到speed, memory和accuracy的平衡。</p></li><li><p>Answering Complex Open-domain Questions Through Iterative Query Generation<br><em>Peng Qi, Xiaowen Lin, Leo Mehr, Zijian Wang, Christopher D. Manning</em>, EMNLP 19<br>在每一步，利用之前hop的IR结果生成一个新的自然语言query，用off-the-shelf的IR系统去retrive新的证据来回答问题。</p></li><li><p>Cognitive Graph for Multi-Hop Reading Comprehension at Scale<br><em>Ming Ding, Chang Zhou, Qibin Chen, Hongxia Yang, Jie Tang</em>, ACL 19<br>根据心理学中的Dual process theory，大脑先无意识地、隐性地、直觉地利用注意力检索相关信息(system 1)，然后有意识地、显性地、可控地进行推理(system 2)。</p><p><strong>下面是对于Commonsense QA的方法和一些引入External Knowledge的方法：</strong></p></li><li><p>Augmenting Neural Networks with First-order Logic<br><em>Tao Li, Vivek Srikumar</em>, ACL19<br>直接把一阶逻辑表示的外部知识（这里用了ConceptNet）嵌入到神经网络架构中，而仍然保持端到端的训练方式，同时依靠这些外部规则来减少对数据的依赖。</p></li><li><p>Align, Mask and Select: A Simple Method for Incorporating Commonsense Knowledge into Language Representation Models<br><em>Zhi-Xiu Ye, Qian Chen, Wen Wang, Zhen-Hua Ling</em><br>现存预训练的语言表示模型很少考虑直接将常识知识嵌入。本文用“align, mask, and select”的方法构造有关常识的数据集，并在它上面预训练BERT，从而将常识知识引入到语言表示模型。</p></li><li><p>Explicit Utilization of General Knowledge in Machine Reading Comprehension 😻<br><em>Chao Wang, Hui Jiang</em>, ACL 19<br>现有MRC模型与人类之间的gap体现在对数据的需求和抵御噪声的鲁棒性。为了缓解这两个问题，作者使用WordNet从passage-question pair中抽取词间语义关系作为general knowledge，来辅助端到端模型中的注意力机制。</p></li><li><p>Enhancing Pre-Trained Language Representations with Rich Knowledge for Machine Reading Comprehension<br><em>An Yang, Quan Wang, Jing Liu, Kai Liu, Yajuan Lyu, Hua Wu, Qiaoqiao She, Sujian Li</em>, ACL 19<br>使用WordNet和NELL两个KB作为MRC的外部知识，通过注意力机制选取需要的知识注入到BERT中，在Record和squad1.1上取得了很好的效果。</p></li><li><p>Careful Selection of Knowledge to solve Open Book Question Answering<br><em>Pratyay Banerjee, Kuntal Kumar Pal, Arindam Mitra, Chitta Baral</em><br>用比较IR的方法做OpenBookQA。</p></li><li><p>KagNet: Knowledge-Aware Graph Networks for Commonsense Reasoning 😻<br>一种类似DBQA的方法，利用ConceptNet建图做COMMONSENSEQA数据集。</p><p><strong>下面是对于Discrete Reasoning和Multi-span Extraction的方法（主要是针对DROP数据集）：</strong><br>DROP数据集答案包含多种类型：data、number、text span(s)，需要numerical operations比如adding、 sorting、counting。</p></li><li><p>A Multi-Type Multi-Span Network for Reading Comprehension that Requires Discrete Reasoning<br><em>Minghao Hu, Yuxing Peng, Zhen Huang, Dongsheng Li</em>, EMNLP 19</p></li><li><p>Giving BERT a Calculator: Finding Operations and Arguments with Reading Comprehension 😻<br><em>Google</em>, EMNLP 19</p></li><li><p>A Discrete Hard EM Approach for Weakly Supervised Question Answering<br><em>Sewon Min, Danqi Chen, Hannaneh Hajishirzi, Luke Zettlemoyer</em>, EMNLP 19</p></li><li><p>Tag-based Multi-Span Extraction in Reading Comprehension<br><em>Avia Efrat, Elad Segal, Mor Shoham</em></p><p><strong>下面是处理Unanswerable Questions的方法：</strong> </p></li><li><p>Relation Module for Non-answerable Prediction on Reading Comprehension<br><em>DiDi</em><br>通过增加relation module来提高MRC模型判断问题是否有答案的能力。</p></li></ul><h2 id="Transfer-Learning-amp-Multi-task-Learning"><a href="#Transfer-Learning-amp-Multi-task-Learning" class="headerlink" title="Transfer Learning &amp; Multi-task Learning"></a>Transfer Learning &amp; Multi-task Learning</h2><ul><li><p>MultiQA: An Empirical Investigation of Generalization and Transfer in Reading Comprehension 😻<br><em>Alon Talmor, Jonathan Berant</em>, ACL 19<br>研究各个MRC数据集能否互相泛化。实验做了很多。</p></li><li><p>Multi-task Learning with Sample Re-weighting for Machine Reading Comprehension<br><em>Yichong Xu, Xiaodong Liu, Yelong Shen, Jingjing Liu, Jianfeng Gao</em>, NAACL 19<br>通过将多个任务的数据集使用精细的采样结合在一起训练，提高模型的泛化性。</p></li><li><p>Unsupervised Domain Adaptation on Reading Comprehension<br>AAAI 20</p></li></ul><h2 id="Question-Generation"><a href="#Question-Generation" class="headerlink" title="Question Generation"></a>Question Generation</h2><ul><li>Learning to Ask Unanswerable Questions for Machine Reading Comprehension 😻<br><em>Haichao Zhu, Li Dong, Furu Wei, Wenhui Wang, Bing Qin, Ting Liu</em>, ACL 19<br>通过一种pair2sequence的方式，由可回答问题和段落生成不可回答问题。生成的不可回答问题当作data augmentation提升了BERT的表现。</li></ul><h2 id="Text-Matching"><a href="#Text-Matching" class="headerlink" title="Text Matching"></a>Text Matching</h2><ul><li><p>MIX: Multi-Channel Information Crossing for Text Matching<br><em>Tencent</em>, KDD 18<br>从多种细粒度进行文本匹配。</p></li><li><p>Enhanced LSTM for Natural Language Inference 😻<br><em>Qian Chen, Xiaodan Zhu, Zhenhua Ling, Si Wei, Hui Jiang, Diana Inkpen</em>, ACL 17<br>一个基于BiLSTM + Attention的很有效的文本匹配模型ESIM。</p></li></ul><h2 id="NLI-Dataset"><a href="#NLI-Dataset" class="headerlink" title="NLI Dataset"></a>NLI Dataset</h2><ul><li>Adversarial NLI: A New Benchmark for Natural Language Understanding 😻<br><em>Facebook</em><br>通过迭代的、对抗性的人类-模型循环，得到了一个大规模的NLI数据集。在这个新数据集上训练的模型在很多NLI数据集上达到state-of-the-art表现。这个数据集也说明了非专家标注者也能成功找到模型们的缺点。数据收集的方法可以运用于never-ending learning，可以成为一个moving target，而非一个快速饱和的静态benchmark。总得来说，解决了现存数据集benchmark longevity和robustness两个问题。</li></ul><h2 id="Story-Ending-Prediction"><a href="#Story-Ending-Prediction" class="headerlink" title="Story Ending Prediction"></a>Story Ending Prediction</h2><p>都是做Story Cloze Test这个数据集的。</p><ul><li>LSDSem 2017: Exploring Data Generation Methods for the Story Cloze Test<br>用了一个feature-based的方法，效果还挺好</li><li>Improving Language Understanding by Generative Pre-Training</li><li>A Multi-Attention based Neural Network with External Knowledge for Story Ending Predicting Task<br>用了SemLM</li><li>An RNN-based Binary Classifier for the Story Cloze Test<br>用了Skip-thought</li><li>A Simple and Effective Approach to the Story Cloze Test<br>用了Skip-thought</li><li>Story Ending Selection by Finding Hints from Pairwise Candidate Endings<br>隔壁的工作，将两个选项同时放入模型进行区分</li><li>Find a Reasonable Ending for Stories: Does Logic Relation Help the Story Cloze Test? 😻<br>AAAI 19。用NLI数据预训练，用逻辑知识辅助判断。</li><li>Narrative Modeling with Memory Chains and Semantic Supervision</li><li>Discriminative Sentence Modeling for Story Ending Prediction<br>AAAI 20</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去年开始认真读论文还是从7月开始，主要读了很多Question Answering的论文，其中又以Machine Reading Comprehension为主，大概了解了QA这个领域在做些什么。&lt;br&gt;这里我把去年读过的论文简单列一下。其中我觉得值得一读的论文我会打上😻。&lt;br&gt;阅读过程中尤其感谢LAI Yuxuan师兄的指导！&lt;/p&gt;
&lt;h2 id=&quot;Survey&quot;&gt;&lt;a href=&quot;#Survey&quot; class=&quot;headerlink&quot; title=&quot;Survey&quot;&gt;&lt;/a&gt;Survey&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NEURAL READING COMPREHENSION AND BEYOND 😻&lt;br&gt;&lt;em&gt;Chen Danqi&lt;/em&gt;&lt;br&gt;陈丹琦的博士毕业论文，一篇对MRC比较全面且易懂的综述。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Neural Machine Reading Comprehension: Methods and Trends&lt;br&gt;&lt;em&gt;Shanshan Liu, Xin Zhang, Sheng Zhang, Hui Wang, Weiming Zhang&lt;/em&gt;&lt;br&gt;国防科大的MRC综述，一些想法很大胆，但一些地方没有讲明白。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Recent Advances in Natural Language Inference: A Survey of Benchmarks, Resources, and Approaches 😻&lt;br&gt;&lt;em&gt;Shane Storks, Qiaozi Gao, Joyce Y. Chai&lt;/em&gt;&lt;br&gt;对于（广义的）Commonsense QA做的综述。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="论文" scheme="http://luciusssss.github.io/categories/%E8%AE%BA%E6%96%87/"/>
    
    
      <category term="论文" scheme="http://luciusssss.github.io/tags/%E8%AE%BA%E6%96%87/"/>
    
      <category term="QA" scheme="http://luciusssss.github.io/tags/QA/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://luciusssss.github.io/2020/01/11/hello-world/"/>
    <id>http://luciusssss.github.io/2020/01/11/hello-world/</id>
    <published>2020-01-11T05:30:39.878Z</published>
    <updated>2020-01-11T10:38:54.372Z</updated>
    
    <content type="html"><![CDATA[<!-- Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues). --><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you g
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
